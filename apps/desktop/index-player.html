<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pandimus Reborn - Desktop RPG</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', 'Times New Roman', serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 50%, #1a1a1a 100%);
            background-image: 
                radial-gradient(circle at 20% 50%, rgba(139, 115, 85, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(212, 175, 55, 0.1) 0%, transparent 50%);
            color: #f0f0f0;
            min-height: 100vh;
            display: flex;
            flex-direction: row;
            margin: 0;
            padding: 0;
        }
        
        /* Persistent Sidebar Navigation */
        .sidebar-nav {
            width: 200px;
            background: linear-gradient(180deg, #3d3d3d 0%, #2d2d2d 100%);
            border-right: 3px solid #8b7355;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.5);
            position: fixed;
            left: 0;
            top: 0;
            height: 100vh;
            overflow-y: auto;
            z-index: 1000;
        }
        
        .sidebar-nav button {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 2px solid #8b7355;
            background: linear-gradient(180deg, #6b5b3d 0%, #4a3d2a 100%);
            color: #f0f0f0;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
            text-align: left;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            font-size: 0.9rem;
        }
        
        .sidebar-nav button:hover {
            background: linear-gradient(180deg, #8b7355 0%, #6b5b3d 100%);
            border-color: #d4af37;
            box-shadow: 0 0 8px rgba(212, 175, 55, 0.4);
        }
        
        .sidebar-nav button.active {
            background: linear-gradient(180deg, #8b7355 0%, #6b5b3d 100%);
            border-color: #d4af37;
            box-shadow: 0 0 12px rgba(212, 175, 55, 0.6);
        }
        
        .sidebar-nav .nav-section {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #8b7355;
        }
        
        .sidebar-nav .nav-section-title {
            color: #d4af37;
            font-size: 0.8rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .header {
            display: none; /* Hidden - using sidebar navigation instead */
        }

        .logo {
            font-size: 1.8rem;
            font-weight: bold;
            color: #d4af37;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8), 0 0 10px rgba(212, 175, 55, 0.5);
            letter-spacing: 1px;
        }

        .nav {
            display: flex;
            gap: 1rem;
        }

        .nav button {
            padding: 0.5rem 1rem;
            border: 2px solid #8b7355;
            background: linear-gradient(180deg, #6b5b3d 0%, #4a3d2a 100%);
            color: #f0f0f0;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .nav button:hover {
            background: linear-gradient(180deg, #8b7355 0%, #6b5b3d 100%);
            border-color: #d4af37;
            box-shadow: 0 0 8px rgba(212, 175, 55, 0.4);
        }

        .main {
            flex: 1;
            padding: 2rem;
            padding-bottom: 4rem; /* Space for fixed footer */
            display: flex;
            justify-content: flex-start;
            align-items: flex-start;
            margin-left: 200px; /* Space for sidebar */
            min-height: 100vh;
            overflow-y: auto;
        }

        .game-container {
            background: linear-gradient(180deg, #f4e4c1 0%, #e8d5b7 100%);
            border: 3px solid #8b7355;
            border-radius: 8px;
            padding: 3rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.3);
            width: 100%;
            text-align: center;
            color: #1a1a1a;
        }

        .welcome {
            margin-bottom: 2rem;
        }

        .welcome h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            color: #8b4513;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            font-weight: bold;
        }

        .welcome p {
            font-size: 1.1rem;
            color: #2d1b0e;
            line-height: 1.6;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
        }

        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .feature {
            padding: 1.5rem;
            background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%);
            border-radius: 8px;
            border: 2px solid #8b7355;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3), 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .feature:hover {
            transform: translateY(-2px);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3), 0 4px 12px rgba(0, 0, 0, 0.4);
            border-color: #d4af37;
        }

        .feature h3 {
            margin-bottom: 0.5rem;
            color: #8b4513;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
        }

        .feature p {
            color: #2d1b0e;
            font-size: 0.9rem;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.3);
        }

        .status {
            margin-top: 2rem;
            padding: 1rem;
            background: linear-gradient(180deg, #c4d4a9 0%, #b4c499 100%);
            border: 2px solid #6b8b3d;
            border-radius: 8px;
            color: #2d4a0e;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.5);
        }

        .controls {
            margin-top: 2rem;
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(180deg, #8b7355 0%, #6b5b3d 100%);
            color: #f0f0f0;
            border: 2px solid #8b7355;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .btn-primary:hover {
            background: linear-gradient(180deg, #a08b6b 0%, #8b7355 100%);
            border-color: #d4af37;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(212, 175, 55, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%);
            color: #2d1b0e;
            border: 2px solid #8b7355;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.5);
        }

        .btn-secondary:hover {
            background: linear-gradient(180deg, #e4d5b9 0%, #d4c5a9 100%);
            border-color: #d4af37;
        }

        .btn-danger {
            background: linear-gradient(180deg, #c41e3a 0%, #a01a2e 100%);
            color: #f0f0f0;
            border: 2px solid #8b1a2a;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .btn-danger:hover {
            background: linear-gradient(180deg, #d42e4a 0%, #c41e3a 100%);
            border-color: #e53e5a;
            box-shadow: 0 4px 12px rgba(196, 30, 58, 0.4);
        }

        .btn-prestige {
            background: linear-gradient(45deg, #d4af37, #ffd700);
            color: #1a1a1a;
            font-weight: bold;
            margin-left: 10px;
            border: 2px solid #b8860b;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.3);
        }

        .btn-prestige:hover {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(212, 175, 55, 0.6);
            border-color: #ffd700;
        }

        /* Inventory Tabs */
        .inventory-tabs {
            display: flex;
            margin-bottom: 1rem;
            border-bottom: 2px solid #8b7355;
        }

        .tab-btn {
            padding: 0.75rem 1.5rem;
            border: none;
            background: transparent;
            color: #2d1b0e;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.3);
        }

        .tab-btn.active {
            color: #8b4513;
            border-bottom-color: #d4af37;
            background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%);
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
        }

        .tab-btn:hover {
            background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%);
        }

        .tab-content {
            min-height: 400px;
        }

        /* Crafting UI */
        .crafting-recipes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .recipe-card {
            background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%);
            border: 2px solid #8b7355;
            border-radius: 8px;
            padding: 1rem;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .recipe-card h4 {
            margin: 0 0 0.5rem 0;
            color: #8b4513;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
        }

        .recipe-materials {
            margin: 0.5rem 0;
            font-size: 0.9rem;
        }

        .recipe-materials span {
            display: inline-block;
            background: linear-gradient(180deg, #8b7355 0%, #6b5b3d 100%);
            color: #f0f0f0;
            padding: 0.2rem 0.5rem;
            margin: 0.2rem;
            border-radius: 4px;
            border: 1px solid #6b5b3d;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .recipe-cost {
            color: #d4af37;
            font-weight: bold;
            margin: 0.5rem 0;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* Materials Grid */
        .materials-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .material-item {
            background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%);
            border: 2px solid #8b7355;
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .material-item h4 {
            margin: 0 0 0.5rem 0;
            color: #8b4513;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
        }

        .material-count {
            font-size: 1.5rem;
            font-weight: bold;
            color: #d4af37;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* Item Actions */
        .item-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
            flex-wrap: wrap;
        }

        .item-actions .btn {
            flex: 1;
            min-width: 60px;
            font-size: 0.8rem;
            padding: 0.4rem 0.6rem;
        }

        /* Character Creation Styling */
        .character-creation {
            background: linear-gradient(180deg, #f4e4c1 0%, #e8d5b7 100%) !important;
            padding: 2rem !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            border: 2px solid #8b7355 !important;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3), 0 4px 12px rgba(0, 0, 0, 0.3) !important;
        }

        .character-creation h3 {
            color: #8b4513 !important;
            margin-bottom: 1rem !important;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5) !important;
        }

        .character-creation p {
            color: #2d1b0e !important;
            margin-bottom: 1.5rem !important;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.3) !important;
        }

        .character-name-input {
            width: 100% !important;
            padding: 0.75rem !important;
            margin-bottom: 1rem !important;
            border: 2px solid #8b7355 !important;
            border-radius: 8px !important;
            font-size: 1rem !important;
            background: #f4e4c1 !important;
            color: #1a1a1a !important;
        }

        .character-name-input::placeholder {
            color: #6b5b3d !important;
        }

        .footer {
            position: fixed;
            bottom: 0;
            left: 200px; /* Account for sidebar */
            right: 0;
            text-align: center;
            padding: 1rem;
            background: linear-gradient(180deg, #2d2d2d 0%, #1a1a1a 100%);
            border-top: 2px solid #8b7355;
            color: #d4af37;
            font-size: 0.9rem;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            z-index: 999;
        }

        /* Character Screen Styles */
        .character-stats {
            margin-bottom: 2rem;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background: rgba(76, 81, 191, 0.1);
            border-radius: 6px;
        }

        .stat-item label {
            font-weight: bold;
            color: #4c51bf;
        }

        .stat-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .stat-btn {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stat-btn.increase {
            background: #48bb78;
            color: white;
        }

        .stat-btn.decrease {
            background: #f56565;
            color: white;
        }

        .stat-btn:hover {
            opacity: 0.8;
        }

        .stat-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .stat-btn:disabled:hover {
            opacity: 0.5;
        }

        /* Toggle Button Styles */
        .toggle-controls {
            display: flex;
            gap: 0.25rem;
            align-items: center;
        }

        .toggle-btn {
            width: 28px;
            height: 28px;
            border: 2px solid #8b7355;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%);
            color: #2d1b0e;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.3);
        }

        .toggle-btn:hover {
            background: linear-gradient(180deg, #e4d5b9 0%, #d4c5a9 100%);
            transform: scale(1.1);
            border-color: #d4af37;
        }

        .toggle-btn.active {
            background: linear-gradient(180deg, #8b7355 0%, #6b5b3d 100%);
            color: #f0f0f0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .toggle-btn[data-state="increase"].active {
            background: linear-gradient(180deg, #4a8b3d 0%, #3a6b2d 100%);
            border-color: #5a9b4d;
        }

        .toggle-btn[data-state="decrease"].active {
            background: linear-gradient(180deg, #c41e3a 0%, #a01a2e 100%);
            border-color: #d42e4a;
        }

        .toggle-btn[data-state="lock"].active {
            background: linear-gradient(180deg, #8b7355 0%, #6b5b3d 100%);
            border-color: #d4af37;
        }

        /* Currency Display */
        .currency-display {
            background: linear-gradient(180deg, #f4e4c1 0%, #e8d5b7 100%);
            border: 2px solid #d4af37;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            text-align: center;
            font-size: 1.1rem;
            font-weight: bold;
            color: #8b4513;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3), 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .char-currency {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: linear-gradient(180deg, #f4e4c1 0%, #e8d5b7 100%);
            border-radius: 6px;
            border: 1px solid #8b7355;
            font-weight: bold;
            color: #8b4513;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.5);
        }

        /* Shop Styles */
        .shops-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .shop-card {
            background: linear-gradient(180deg, #f4e4c1 0%, #e8d5b7 100%);
            border: 2px solid #8b7355;
            border-radius: 8px;
            padding: 1.5rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3), 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .shop-card:hover {
            border-color: #d4af37;
            transform: translateY(-2px);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3), 0 4px 12px rgba(212, 175, 55, 0.3);
        }

        .shop-icon {
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }

        .shop-card h3 {
            margin: 0.5rem 0;
            color: #8b4513;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
        }

        .shop-card p {
            color: #2d1b0e;
            margin: 0.5rem 0;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.3);
        }

        .reputation {
            font-weight: bold;
            color: #8b4513;
            margin: 0.5rem 0;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.5);
        }

        .shop-status {
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
            background: linear-gradient(180deg, #4a8b3d 0%, #3a6b2d 100%);
            color: #f0f0f0;
            display: inline-block;
            border: 1px solid #3a6b2d;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .shop-layout {
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 2rem;
            margin: 2rem 0;
        }

        .shop-sidebar {
            background: linear-gradient(180deg, #f4e4c1 0%, #e8d5b7 100%);
            border: 2px solid #8b7355;
            border-radius: 8px;
            padding: 1.5rem;
            height: fit-content;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3), 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .vendor-info {
            margin-bottom: 1.5rem;
        }

        .vendor-info h3 {
            color: #8b4513;
            margin-bottom: 0.5rem;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
        }

        .vendor-info p {
            color: #2d1b0e;
            margin: 0.25rem 0;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.3);
        }

        .shop-tabs {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .tab-btn {
            padding: 0.75rem 1rem;
            border: 2px solid #8b7355;
            background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            color: #2d1b0e;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.3);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .tab-btn:hover {
            border-color: #d4af37;
            background: linear-gradient(180deg, #e4d5b9 0%, #d4c5a9 100%);
        }

        .tab-btn.active {
            background: linear-gradient(180deg, #8b7355 0%, #6b5b3d 100%);
            color: #f0f0f0;
            border-color: #d4af37;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .shop-tab {
            display: none;
        }

        .shop-tab.active {
            display: block;
        }

        .item-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
        }

        .quest-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .quest-item {
            background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%);
            border: 2px solid #8b7355;
            border-radius: 8px;
            padding: 1rem;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .quest-item h4 {
            margin: 0 0 0.5rem 0;
            color: #8b4513;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
        }

        .quest-item p {
            color: #2d1b0e;
            margin: 0.25rem 0;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.3);
        }

        /* Map Location Styles */
        .location-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .location-info {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin: 0.5rem 0;
        }

        .location-level {
            background: linear-gradient(180deg, #8b7355 0%, #6b5b3d 100%);
            color: #f0f0f0;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
            border: 1px solid #6b5b3d;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .location-stats {
            margin-top: 0.5rem;
            color: #2d1b0e;
            font-size: 0.9rem;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.3);
        }

        /* Difficulty Colors */
        .difficulty-beginner {
            background: #48bb78;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .difficulty-intermediate {
            background: #ed8936;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .difficulty-advanced {
            background: #e53e3e;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .difficulty-expert {
            background: #9f7aea;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .difficulty-master {
            background: #2d3748;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .character-actions {
            margin-top: 2rem;
        }

        .character-name-input {
            padding: 0.5rem;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            margin-right: 0.5rem;
            width: 150px;
        }

        /* New Character Screen Styles */
        .character-creation {
            text-align: center;
            padding: 2rem;
            background: rgba(76, 81, 191, 0.1);
            border-radius: 12px;
            margin: 2rem 0;
        }

        .name-input-section {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            margin-top: 1rem;
        }

        .character-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding: 1rem;
            background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%);
            border: 2px solid #8b7355;
            border-radius: 8px;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .char-name-section h3 {
            margin: 0;
            color: #8b4513;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
        }

        .name-edit {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .char-level {
            font-size: 1.2rem;
            font-weight: bold;
            color: #8b4513;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
        }

        .character-main-layout {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 2rem;
            margin: 2rem 0;
        }

        .equipment-panel, .stats-panel, .skills-panel {
            background: linear-gradient(180deg, #f4e4c1 0%, #e8d5b7 100%);
            border: 2px solid #8b7355;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3), 0 4px 12px rgba(0, 0, 0, 0.3);
            color: #1a1a1a;
        }
        
        .equipment-panel h3, .stats-panel h3, .skills-panel h3 {
            color: #8b4513;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
            margin-bottom: 1rem;
        }

        .equipment-layout {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        
        .equipment-column {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            flex: 1;
        }
        
        .equipment-bottom {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
        }

        .equipment-slot {
            text-align: center;
            padding: 1rem;
            background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%);
            border-radius: 6px;
            border: 2px solid #8b7355;
            transition: all 0.2s;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .equipment-slot:hover {
            border-color: #d4af37;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3), 0 2px 8px rgba(212, 175, 55, 0.3);
        }

        .slot-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .slot-label {
            font-weight: bold;
            color: #8b4513;
            margin-bottom: 0.5rem;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.5);
        }

        .slot-item {
            font-size: 0.9rem;
            color: #2d1b0e;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.3);
        }

        .attributes-grid {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .attribute-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%);
            border: 1px solid #8b7355;
            border-radius: 6px;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }
        
        .attribute-item label {
            color: #8b4513;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.5);
        }
        
        .attribute-value {
            color: #2d1b0e;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.3);
        }

        .attribute-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .attribute-value {
            min-width: 40px;
            text-align: center;
            font-weight: bold;
        }

        .derived-stats {
            border-top: 2px solid rgba(76, 81, 191, 0.2);
            padding-top: 1rem;
        }

        .derived-stats h4 {
            margin-bottom: 1rem;
            color: #8b4513;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
        }

        .derived-stat {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid #8b7355;
            color: #2d1b0e;
        }
        
        .derived-stat label {
            color: #8b4513;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.5);
        }
        
        .derived-stat span {
            color: #2d1b0e;
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.3);
        }

        .derived-stat:last-child {
            border-bottom: none;
        }

        .skills-categories {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .skill-category h4 {
            margin-bottom: 1rem;
            color: #8b4513;
            border-bottom: 2px solid #8b7355;
            padding-bottom: 0.5rem;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
        }

        .skill-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .skill-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%);
            border: 1px solid #8b7355;
            border-radius: 6px;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }
        
        .skill-name {
            color: #8b4513;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.5);
        }

        .skill-name {
            font-size: 0.9rem;
            font-weight: 500;
        }

        .skill-controls {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .toggle-controls {
            display: flex;
            gap: 0.1rem;
        }

        .toggle-btn {
            background: #4c51bf;
            color: white;
            border: none;
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        .toggle-btn:hover {
            background: #434190;
        }
        
        .toggle-btn.active {
            background: #e53e3e;
            box-shadow: 0 0 0 2px #fed7e2;
        }

        /* Tooltip styles */
        .item-card {
            position: relative;
        }

        .item-card:hover::after {
            content: attr(title);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(180deg, #2d1b0e 0%, #1a1008 100%);
            color: #f0f0f0;
            padding: 8px 12px;
            border: 2px solid #d4af37;
            border-radius: 4px;
            font-size: 12px;
            white-space: pre-line;
            z-index: 1000;
            min-width: 200px;
            max-width: 300px;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.8);
        }

        .item-card:hover::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(100%);
            border: 5px solid transparent;
            border-top-color: #2d1b0e;
            z-index: 1000;
            pointer-events: none;
        }

        .skill-value {
            min-width: 35px;
            text-align: center;
            font-size: 0.9rem;
            font-weight: bold;
        }

        /* Inventory Screen Styles */
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .item-slot {
            padding: 1rem;
            background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%);
            border-radius: 8px;
            border: 2px solid #8b7355;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .item-slot:hover {
            border-color: #d4af37;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3), 0 2px 8px rgba(212, 175, 55, 0.3);
        }

        .item-slot.equipped {
            border-color: #4a8b3d;
            background: linear-gradient(180deg, #b4d4a9 0%, #a4c499 100%);
        }

        .item-name {
            font-weight: bold;
            margin-bottom: 0.5rem;
            color: #8b4513;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.5);
        }

        .item-stats {
            font-size: 0.8rem;
            color: #2d1b0e;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.3);
        }

        /* Map Screen Styles */
        .map-viewport-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin: 2rem 0;
        }

        .map-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
            padding: 1rem;
            background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%);
            border: 2px solid #8b7355;
            border-radius: 8px;
        }

        .map-info {
            flex: 1;
            min-width: 200px;
        }

        .map-info-item {
            margin: 0.25rem 0;
            color: #2d1b0e;
            font-size: 0.9rem;
        }

        .map-info-item strong {
            color: #8b4513;
        }

        .movement-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            max-width: 200px;
        }

        .movement-controls button {
            padding: 0.75rem;
            border: 2px solid #8b7355;
            background: linear-gradient(180deg, #6b5b3d 0%, #4a3d2a 100%);
            color: #f0f0f0;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .movement-controls button:hover:not(:disabled) {
            background: linear-gradient(180deg, #8b7355 0%, #6b5b3d 100%);
            border-color: #d4af37;
        }

        .movement-controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .movement-controls button:nth-child(2) {
            grid-column: 2;
        }

        .movement-controls button:nth-child(4) {
            grid-column: 1;
        }

        .movement-controls button:nth-child(5) {
            grid-column: 3;
        }

        .movement-controls button:nth-child(6) {
            grid-column: 2;
        }

        .map-grid-container {
            position: relative;
            background: #1a1a1a;
            border: 3px solid #8b7355;
            border-radius: 8px;
            overflow: hidden;
            width: 100%;
            height: 100%;
            min-height: 400px;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
        }
        
        #map-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Biome Square Panel Styles */
        .biome-square-panel {
            padding: 1rem;
            background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%);
            border: 2px solid #8b7355;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .biome-panel-header {
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #8b7355;
        }

        .biome-panel-content {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .biome-info-section,
        .biome-enemies-section,
        .biome-resources-section {
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            border: 1px solid rgba(139, 115, 85, 0.3);
        }

        .biome-description {
            color: #2d1b0e;
            font-size: 0.9rem;
            margin-bottom: 0.75rem;
            line-height: 1.4;
        }

        .biome-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 0.5rem;
            font-size: 0.85rem;
            color: #2d1b0e;
        }

        .biome-stats div {
            padding: 0.25rem 0;
        }

        .biome-stats strong {
            color: #8b4513;
        }

        .biome-entities-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: 300px;
            overflow-y: auto;
        }

        .biome-entity-item {
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.3);
            border: 1px solid rgba(139, 115, 85, 0.4);
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.5rem;
        }

        .biome-entity-info {
            flex: 1;
            color: #2d1b0e;
            font-size: 0.85rem;
        }

        .biome-entity-name {
            font-weight: bold;
            color: #8b4513;
        }

        .biome-entity-actions {
            display: flex;
            gap: 0.25rem;
        }

        .biome-entity-actions button {
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            border: 1px solid #8b7355;
            background: linear-gradient(180deg, #6b5b3d 0%, #4a3d2a 100%);
            color: #f0f0f0;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .biome-entity-actions button:hover {
            background: linear-gradient(180deg, #8b7355 0%, #6b5b3d 100%);
            border-color: #d4af37;
        }

        .biome-empty-message {
            color: #666;
            font-style: italic;
            text-align: center;
            padding: 1rem;
        }

        .map-grid {
            display: grid;
            gap: 0;
            position: relative;
            margin: 0 auto;
        }

        .map-square {
            width: 8px;
            height: 8px;
            border: 0.5px solid rgba(255, 255, 255, 0.1);
            position: relative;
            cursor: pointer;
            transition: all 0.1s;
        }

        .map-square:hover {
            border-color: rgba(212, 175, 55, 0.5);
            z-index: 10;
            transform: scale(1.5);
        }

        .map-square.unexplored {
            background: #0a0a0a;
            opacity: 0.3;
        }

        .map-square.explored {
            opacity: 1;
        }

        .map-square.player {
            background: #d4af37 !important;
            border: 2px solid #fff;
            box-shadow: 0 0 10px #d4af37, 0 0 20px #d4af37;
            z-index: 100;
            transform: scale(2);
        }

        .map-square.town {
            background: #8b4513 !important;
            border: 2px solid #d4af37;
            box-shadow: 0 0 5px #8b4513;
            z-index: 50;
        }

        .map-square.town::after {
            content: 'üèòÔ∏è';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            line-height: 1;
        }

        .map-legend {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            padding: 1rem;
            background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%);
            border: 2px solid #8b7355;
            border-radius: 8px;
        }

        .map-legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            color: #2d1b0e;
        }

        .map-legend-color {
            width: 20px;
            height: 20px;
            border: 1px solid #8b7355;
            border-radius: 3px;
        }

        .map-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: #f0f0f0;
            padding: 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 1000;
            border: 1px solid #d4af37;
            display: none;
        }

        .map-tooltip.visible {
            display: block;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .modal-content {
            background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%);
            border: 2px solid #8b7355;
            border-radius: 8px;
            padding: 2rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
        }

        /* Combat Screen Styles */
        .combat-area {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 2rem 0;
            padding: 2rem;
            background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%);
            border: 2px solid #8b7355;
            border-radius: 8px;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3), 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .combatant {
            color: #1a1a1a;
        }
        
        .combatant h3 {
            color: #8b4513;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
        }

        .combatant {
            text-align: center;
            flex: 1;
        }

        .vs {
            font-size: 2rem;
            font-weight: bold;
            color: #8b4513;
            margin: 0 2rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5), 0 0 10px rgba(212, 175, 55, 0.5);
        }

        .health-bar {
            width: 200px;
            height: 24px;
            background: #2d1b0e;
            border: 2px solid #8b7355;
            border-radius: 4px;
            overflow: hidden;
            margin: 0.5rem auto;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #c41e3a, #a01a2e);
            transition: width 0.3s ease;
            box-shadow: 0 0 8px rgba(196, 30, 58, 0.6);
        }

        .enemy-health {
            background: linear-gradient(90deg, #c41e3a, #8b1a2a);
            box-shadow: 0 0 8px rgba(196, 30, 58, 0.6);
        }

        .combat-actions {
            margin: 2rem 0;
        }

        .combat-log {
            margin: 2rem 0;
            padding: 1rem;
            background: linear-gradient(180deg, #2d1b0e 0%, #1a1008 100%);
            border: 2px solid #8b7355;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            color: #f0f0f0;
            font-family: 'Courier New', monospace;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .combat-log div {
            color: #f0f0f0;
            margin: 0.25rem 0;
            padding: 0.25rem;
        }

        .combat-controls {
            margin-top: 2rem;
        }

        /* Tooltip Styles */
        .tooltip {
            position: relative;
            cursor: help;
        }

        .tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(180deg, #2d1b0e 0%, #1a1008 100%);
            color: #f0f0f0;
            padding: 0.5rem;
            border: 2px solid #d4af37;
            border-radius: 4px;
            font-size: 0.8rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.8);
        }

        .tooltip:hover::after {
            opacity: 1;
        }
    </style>
</head>
<body>
    <!-- Persistent Sidebar Navigation -->
    <nav class="sidebar-nav">
        <div class="logo" style="color: #d4af37; font-size: 1.2rem; font-weight: bold; margin-bottom: 1rem; text-align: center; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);">Pandimus Reborn</div>
        
        <div class="nav-section">
            <div class="nav-section-title">Main</div>
            <button onclick="showWelcome()" id="nav-welcome">Home</button>
            <button onclick="showCharacter()" id="nav-character">Character</button>
            <button onclick="showMap()" id="nav-map">Map</button>
            <button onclick="showInventory()" id="nav-inventory">Inventory</button>
        </div>
        
        <div class="nav-section">
            <div class="nav-section-title">Combat</div>
            <button onclick="showEncounters()" id="nav-encounters">Encounters</button>
        </div>
        
        <div class="nav-section">
            <div class="nav-section-title">Trade</div>
            <button onclick="showShops()" id="nav-shops">Shops</button>
        </div>
    </nav>

    <main class="main">
        <!-- Welcome Screen -->
        <div id="welcome-screen" class="game-container">
            <div class="welcome">
                <h1>Pandimus Reborn</h1>
                <p>In the ancient realm of Pandimus, where magic flows through every stone and shadow, you are a newly awakened adventurer. The world teeters on the edge of chaos as ancient evils stir in forgotten depths. Your journey begins here, but where it ends depends on the choices you make and the power you forge.</p>
                <div class="lore-section" style="margin-top: 1rem; padding: 1rem; background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%); border-radius: 8px; border-left: 4px solid #d4af37; border: 2px solid #8b7355;">
                    <h4 style="color: #8b4513; margin: 0 0 0.5rem 0; text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);">The Prophecy of Rebirth</h4>
                    <p style="margin: 0; font-size: 0.9rem; color: #2d1b0e; text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.3);">
                        "When the stars align and the void stirs, a chosen one shall rise from the ashes of the old world. Through trials of fire and shadow, they will forge a new destiny for Pandimus."
                    </p>
                </div>
            </div>

            <div class="features">
                <div class="feature" onclick="showCharacter()">
                    <h3>Character</h3>
                    <p>Manage your character's attributes, equipment, and progression through strategic choices.</p>
                </div>
                <div class="feature" onclick="showMap()">
                    <h3>Map</h3>
                    <p>Explore different locations, each with unique challenges and opportunities for growth.</p>
                </div>
                <div class="feature" onclick="showInventory()">
                    <h3>Inventory</h3>
                    <p>Manage your equipment and items to optimize your character's combat effectiveness.</p>
                </div>
                <div class="feature" onclick="showEncounters()">
                    <h3>Encounters</h3>
                    <p>Face various creatures and challenges as you explore the world of Pandimus.</p>
                </div>
                <div class="feature" onclick="showShops()">
                    <h3>Shops</h3>
                    <p>Visit merchants to buy and sell equipment, and complete quests to gain reputation.</p>
                </div>
            </div>

            <div class="status">
                <strong>Adventure Awaits</strong><br>
                Create your character and begin your journey through the mystical realm of Pandimus.
            </div>

            <div class="currency-display">
                <span>üí∞ Gold: <span id="main-gold">100</span></span>
            </div>

            <div class="controls">
                <button class="btn btn-primary" onclick="startNewGame()">Start New Adventure</button>
                <button class="btn btn-secondary" onclick="loadGame()">Load Game</button>
            </div>
        </div>

        <!-- Character Screen -->
        <div id="character-screen" class="game-container" style="display: none;">
            <div class="welcome">
                <h1>Character Management</h1>
                <p>In Pandimus, power comes not just from raw strength, but from the harmony between body, mind, and spirit. As you grow stronger, you'll discover that true mastery lies in understanding the ancient arts of combat, magic, and the delicate balance between them.</p>
                <div class="lore-section" style="margin-top: 1rem; padding: 1rem; background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%); border-radius: 8px; border-left: 4px solid #d4af37; border: 2px solid #8b7355;">
                    <h4 style="color: #8b4513; margin: 0 0 0.5rem 0; text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);">The Three Pillars of Power</h4>
                    <p style="margin: 0; font-size: 0.9rem; color: #2d1b0e; text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.3);">
                        <strong style="color: #8b4513;">Power:</strong> The raw force that drives your attacks and magical prowess.<br>
                        <strong style="color: #8b4513;">Dexterity:</strong> The finesse that determines your accuracy and magical control.<br>
                        <strong style="color: #8b4513;">Vitality:</strong> The endurance that sustains you through the longest battles.
                    </p>
                </div>
            </div>

            <div id="character-content">
                <!-- Character Creation Section -->
                <div id="no-character-section" style="display: block;">
                    <div class="character-creation" style="background: linear-gradient(180deg, #f4e4c1 0%, #e8d5b7 100%); padding: 2rem; border-radius: 8px; margin: 1rem 0; border: 2px solid #8b7355;">
                        <h3 style="color: #8b4513; margin-bottom: 1rem; text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);">Create Your Character</h3>
                        <p style="color: #2d1b0e; margin-bottom: 1.5rem; text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.3);">No character created yet. Create one to start your adventure!</p>
                        <div class="name-input-section">
                            <input type="text" id="char-name-input" class="character-name-input" placeholder="Enter character name" style="width: 100%; padding: 0.75rem; margin-bottom: 1rem; border: 2px solid #4c51bf; border-radius: 8px; font-size: 1rem; background: #fff; color: #000; pointer-events: auto;" autocomplete="off" tabindex="0" onfocus="this.select()" onkeydown="if(event.key === 'Enter') { createNewCharacter(); }">
                            <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                                <button class="btn btn-primary" onclick="createNewCharacter()">Create Character</button>
                                <button class="btn btn-secondary" onclick="testFunction()">Test JS</button>
                                <button class="btn btn-secondary" onclick="forceShowCharacterCreation()">Force Show Creation</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Character Display Section -->
                <div id="character-display-section" style="display: none;">
                    <!-- Character Info -->
                    <div class="character-info">
                        <div class="char-name-section">
                            <h3 id="displayed-name">Adventurer</h3>
                            <div class="name-edit">
                                <input type="text" id="char-name-edit" class="character-name-input" placeholder="Enter name">
                                <button class="btn btn-secondary" onclick="updateCharacterName()">Update Name</button>
                                <button class="btn btn-danger" onclick="resetCharacterData()">Reset Character</button>
                            </div>
                        </div>
                <div class="char-level">
                    <span>Rank: <span id="char-level">Novice (Tier 1)</span></span>
                    <button class="btn btn-prestige" onclick="attemptPrestige()" id="prestige-btn" style="display: none;">Prestige</button>
                </div>
                        <div class="char-currency">
                            <span>üí∞ Gold: <span id="char-gold">100</span></span>
                        </div>
                    </div>

                    <!-- Equipment and Stats Layout -->
                    <div class="character-main-layout">
                        <!-- Left: Equipment Slots -->
                        <div class="equipment-panel">
                            <h3>Equipment</h3>
                            <div class="equipment-layout">
                                <!-- Left Column -->
                                <div class="equipment-column">
                                    <div class="equipment-slot">
                                        <div class="slot-icon">‚õëÔ∏è</div>
                                        <div class="slot-label">Helmet</div>
                                        <div class="slot-item" id="equipped-helmet-display">None</div>
                                    </div>
                                    <div class="equipment-slot">
                                        <div class="slot-icon">ü¶æ</div>
                                        <div class="slot-label">Shoulders</div>
                                        <div class="slot-item" id="equipped-shoulders-display">None</div>
                                    </div>
                                    <div class="equipment-slot">
                                        <div class="slot-icon">ü¶∫</div>
                                        <div class="slot-label">Chest</div>
                                        <div class="slot-item" id="equipped-chest-display">None</div>
                                    </div>
                                    <div class="equipment-slot">
                                        <div class="slot-icon">ü¶ø</div>
                                        <div class="slot-label">Bracers</div>
                                        <div class="slot-item" id="equipped-bracers-display">None</div>
                                    </div>
                                    <div class="equipment-slot">
                                        <div class="slot-icon">üß§</div>
                                        <div class="slot-label">Gloves</div>
                                        <div class="slot-item" id="equipped-gloves-display">None</div>
                                    </div>
                                    <div class="equipment-slot">
                                        <div class="slot-icon">üíç</div>
                                        <div class="slot-label">Ring 1</div>
                                        <div class="slot-item" id="equipped-ring1-display">None</div>
                                    </div>
                                    <div class="equipment-slot">
                                        <div class="slot-icon">üíç</div>
                                        <div class="slot-label">Ring 2</div>
                                        <div class="slot-item" id="equipped-ring2-display">None</div>
                                    </div>
                                </div>
                                
                                <!-- Right Column -->
                                <div class="equipment-column">
                                    <div class="equipment-slot">
                                        <div class="slot-icon">üìø</div>
                                        <div class="slot-label">Necklace</div>
                                        <div class="slot-item" id="equipped-necklace-display">None</div>
                                    </div>
                                    <div class="equipment-slot">
                                        <div class="slot-icon">üß•</div>
                                        <div class="slot-label">Cape</div>
                                        <div class="slot-item" id="equipped-cape-display">None</div>
                                    </div>
                                    <div class="equipment-slot">
                                        <div class="slot-icon">ü¶Ø</div>
                                        <div class="slot-label">Belt</div>
                                        <div class="slot-item" id="equipped-belt-display">None</div>
                                    </div>
                                    <div class="equipment-slot">
                                        <div class="slot-icon">üëñ</div>
                                        <div class="slot-label">Pants</div>
                                        <div class="slot-item" id="equipped-pants-display">None</div>
                                    </div>
                                    <div class="equipment-slot">
                                        <div class="slot-icon">üë¢</div>
                                        <div class="slot-label">Boots</div>
                                        <div class="slot-item" id="equipped-boots-display">None</div>
                                    </div>
                                    <div class="equipment-slot">
                                        <div class="slot-icon">üíç</div>
                                        <div class="slot-label">Ring 3</div>
                                        <div class="slot-item" id="equipped-ring3-display">None</div>
                                    </div>
                                    <div class="equipment-slot">
                                        <div class="slot-icon">üíç</div>
                                        <div class="slot-label">Ring 4</div>
                                        <div class="slot-item" id="equipped-ring4-display">None</div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Bottom Row -->
                            <div class="equipment-bottom">
                                <div class="equipment-slot">
                                    <div class="slot-icon">‚öîÔ∏è</div>
                                    <div class="slot-label">Main Hand</div>
                                    <div class="slot-item" id="equipped-mainhand-display">None</div>
                                </div>
                                <div class="equipment-slot">
                                    <div class="slot-icon">üõ°Ô∏è</div>
                                    <div class="slot-label">Off Hand</div>
                                    <div class="slot-item" id="equipped-offhand-display">None</div>
                                </div>
                                <div class="equipment-slot">
                                    <div class="slot-icon">üîÆ</div>
                                    <div class="slot-label">Trinket 1</div>
                                    <div class="slot-item" id="equipped-trinket1-display">None</div>
                                </div>
                                <div class="equipment-slot">
                                    <div class="slot-icon">üîÆ</div>
                                    <div class="slot-label">Trinket 2</div>
                                    <div class="slot-item" id="equipped-trinket2-display">None</div>
                                </div>
                            </div>
                        </div>

                        <!-- Center: Stats -->
                        <div class="stats-panel">
                            <h3>Primary Skills</h3>
                            <div class="attributes-grid">
                                <div class="attribute-item">
                                    <label class="tooltip" data-tooltip="Power affects your attack damage and physical abilities">Power:</label>
                                    <div class="attribute-controls">
                                        <span class="attribute-value" id="char-power">0.0</span>
                                        <div class="toggle-controls">
                                            <button class="toggle-btn" data-skill="Power" data-state="decrease" onclick="toggleSkill('Power', 'decrease')" id="power-decrease">üìâ</button>
                                            <button class="toggle-btn" data-skill="Power" data-state="lock" onclick="toggleSkill('Power', 'lock')" id="power-lock">üîí</button>
                                            <button class="toggle-btn" data-skill="Power" data-state="increase" onclick="toggleSkill('Power', 'increase')" id="power-increase">üìà</button>
                                        </div>
                                    </div>
                                </div>
                                <div class="attribute-item">
                                    <label class="tooltip" data-tooltip="Dexterity affects your accuracy, dodge chance, and initiative">Dexterity:</label>
                                    <div class="attribute-controls">
                                        <span class="attribute-value" id="char-dex">0.0</span>
                                        <div class="toggle-controls">
                                            <button class="toggle-btn" data-skill="Dexterity" data-state="decrease" onclick="toggleSkill('Dexterity', 'decrease')" id="dex-decrease">üìâ</button>
                                            <button class="toggle-btn" data-skill="Dexterity" data-state="lock" onclick="toggleSkill('Dexterity', 'lock')" id="dex-lock">üîí</button>
                                            <button class="toggle-btn" data-skill="Dexterity" data-state="increase" onclick="toggleSkill('Dexterity', 'increase')" id="dex-increase">üìà</button>
                                        </div>
                                    </div>
                                </div>
                                <div class="attribute-item">
                                    <label class="tooltip" data-tooltip="Vitality affects your health, stamina, and resistance to status effects">Vitality:</label>
                                    <div class="attribute-controls">
                                        <span class="attribute-value" id="char-vit">0.0</span>
                                        <div class="toggle-controls">
                                            <button class="toggle-btn" data-skill="Vitality" data-state="decrease" onclick="toggleSkill('Vitality', 'decrease')" id="vit-decrease">üìâ</button>
                                            <button class="toggle-btn" data-skill="Vitality" data-state="lock" onclick="toggleSkill('Vitality', 'lock')" id="vit-lock">üîí</button>
                                            <button class="toggle-btn" data-skill="Vitality" data-state="increase" onclick="toggleSkill('Vitality', 'increase')" id="vit-increase">üìà</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                        <div class="derived-stats">
                            <h4>Combat Stats</h4>
                            <div class="derived-stat">
                                <label>Health:</label>
                                <span id="char-hp">100/100</span>
                            </div>
                            <div class="derived-stat">
                                <label>Damage:</label>
                                <span id="damage-range">50 - 60</span>
                            </div>
                            <div class="derived-stat">
                                <label>Type:</label>
                                <span id="damage-type">Physical</span>
                            </div>
                            <div class="derived-stat">
                                <label>Attack Rating:</label>
                                <span id="attack-rating">50</span>
                            </div>
                            <div class="derived-stat">
                                <label>Critical:</label>
                                <span id="crit-chance">0%</span>
                            </div>
                            <div class="derived-stat">
                                <label>Armor:</label>
                                <span id="total-armor">0</span>
                            </div>
                            <div class="derived-stat">
                                <label>Magic Resist:</label>
                                <span id="total-magic-resist">0</span>
                            </div>
                            <div class="derived-stat">
                                <label>Block:</label>
                                <span id="block-chance">0%</span>
                            </div>
                            <div class="derived-stat">
                                <label>Parry:</label>
                                <span id="parry-chance">0%</span>
                            </div>
                            <div class="derived-stat">
                                <label>Dodge:</label>
                                <span id="dodge-chance">0%</span>
                            </div>
                            <div class="derived-stat">
                                <label>First Aid:</label>
                                <span id="first-aid-value">0</span>
                            </div>
                            <div class="derived-stat">
                                <label>Restoration:</label>
                                <span id="restoration-value">0</span>
                            </div>
                        </div>
                        </div>

                    <!-- Right: Skills Panel -->
                    <div class="skills-panel">
                        <h3>Secondary Skills</h3>
                        <div class="skills-categories">
                            <div class="skill-category">
                                <h4>Power Skills</h4>
                                <div class="skill-list">
                                    <div class="skill-item">
                                        <span class="skill-name tooltip" data-tooltip="Increase damage using magical based attacks">Concentration</span>
                                        <div class="skill-controls">
                                            <span class="skill-value" id="skill-concentration">0.0</span>
                                            <div class="toggle-controls">
                                                <button class="toggle-btn" data-skill="Concentration" data-state="decrease" onclick="toggleSkill('Concentration', 'decrease')">üìâ</button>
                                                <button class="toggle-btn" data-skill="Concentration" data-state="lock" onclick="toggleSkill('Concentration', 'lock')">üîí</button>
                                                <button class="toggle-btn" data-skill="Concentration" data-state="increase" onclick="toggleSkill('Concentration', 'increase')">üìà</button>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="skill-item">
                                        <span class="skill-name tooltip" data-tooltip="Decrease physical based attacks against you">Defense</span>
                                        <div class="skill-controls">
                                            <span class="skill-value" id="skill-defense">0.0</span>
                                            <div class="toggle-controls">
                                                <button class="toggle-btn" data-skill="Defense" data-state="decrease" onclick="toggleSkill('Defense', 'decrease')">üìâ</button>
                                                <button class="toggle-btn" data-skill="Defense" data-state="lock" onclick="toggleSkill('Defense', 'lock')">üîí</button>
                                                <button class="toggle-btn" data-skill="Defense" data-state="increase" onclick="toggleSkill('Defense', 'increase')">üìà</button>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="skill-item">
                                        <span class="skill-name tooltip" data-tooltip="Increases your block chance when wielding shields">Blocking</span>
                                        <div class="skill-controls">
                                            <span class="skill-value" id="skill-blocking">0.0</span>
                                            <div class="toggle-controls">
                                                <button class="toggle-btn" data-skill="Blocking" data-state="decrease" onclick="toggleSkill('Blocking', 'decrease')">üìâ</button>
                                                <button class="toggle-btn" data-skill="Blocking" data-state="lock" onclick="toggleSkill('Blocking', 'lock')">üîí</button>
                                                <button class="toggle-btn" data-skill="Blocking" data-state="increase" onclick="toggleSkill('Blocking', 'increase')">üìà</button>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="skill-item">
                                        <span class="skill-name tooltip" data-tooltip="Increase chance to block and redirect damage back at the attacker">Parrying</span>
                                        <div class="skill-controls">
                                            <span class="skill-value" id="skill-parrying">0.0</span>
                                            <div class="toggle-controls">
                                                <button class="toggle-btn" data-skill="Parrying" data-state="decrease" onclick="toggleSkill('Parrying', 'decrease')">üìâ</button>
                                                <button class="toggle-btn" data-skill="Parrying" data-state="lock" onclick="toggleSkill('Parrying', 'lock')">üîí</button>
                                                <button class="toggle-btn" data-skill="Parrying" data-state="increase" onclick="toggleSkill('Parrying', 'increase')">üìà</button>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="skill-item">
                                        <span class="skill-name tooltip" data-tooltip="Increase damage using physical based attacks">Anatomy</span>
                                        <div class="skill-controls">
                                            <span class="skill-value" id="skill-anatomy">0.0</span>
                                            <div class="toggle-controls">
                                                <button class="toggle-btn" data-skill="Anatomy" data-state="decrease" onclick="toggleSkill('Anatomy', 'decrease')">üìâ</button>
                                                <button class="toggle-btn" data-skill="Anatomy" data-state="lock" onclick="toggleSkill('Anatomy', 'lock')">üîí</button>
                                                <button class="toggle-btn" data-skill="Anatomy" data-state="increase" onclick="toggleSkill('Anatomy', 'increase')">üìà</button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="skill-category">
                                <h4>Dexterity Skills</h4>
                                <div class="skill-list">
                                    <div class="skill-item">
                                        <span class="skill-name tooltip" data-tooltip="Increased chance to dodge incoming attacks">Dodging</span>
                                        <div class="skill-controls">
                                            <span class="skill-value" id="skill-dodging">0.0</span>
                                            <div class="toggle-controls">
                                                <button class="toggle-btn" data-skill="Dodging" data-state="decrease" onclick="toggleSkill('Dodging', 'decrease')">üìâ</button>
                                                <button class="toggle-btn" data-skill="Dodging" data-state="lock" onclick="toggleSkill('Dodging', 'lock')">üîí</button>
                                                <button class="toggle-btn" data-skill="Dodging" data-state="increase" onclick="toggleSkill('Dodging', 'increase')">üìà</button>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="skill-item">
                                        <span class="skill-name tooltip" data-tooltip="Increase chance to crit with physical based attacks">Fury Control</span>
                                        <div class="skill-controls">
                                            <span class="skill-value" id="skill-furycontrol">0.0</span>
                                            <div class="toggle-controls">
                                                <button class="toggle-btn" data-skill="FuryControl" data-state="decrease" onclick="toggleSkill('FuryControl', 'decrease')">üìâ</button>
                                                <button class="toggle-btn" data-skill="FuryControl" data-state="lock" onclick="toggleSkill('FuryControl', 'lock')">üîí</button>
                                                <button class="toggle-btn" data-skill="FuryControl" data-state="increase" onclick="toggleSkill('FuryControl', 'increase')">üìà</button>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="skill-item">
                                        <span class="skill-name tooltip" data-tooltip="When in a group, increases the chance you'll be targeted by the enemy">Provocation</span>
                                        <div class="skill-controls">
                                            <span class="skill-value" id="skill-provocation">0.0</span>
                                            <div class="toggle-controls">
                                                <button class="toggle-btn" data-skill="Provocation" data-state="decrease" onclick="toggleSkill('Provocation', 'decrease')">üìâ</button>
                                                <button class="toggle-btn" data-skill="Provocation" data-state="lock" onclick="toggleSkill('Provocation', 'lock')">üîí</button>
                                                <button class="toggle-btn" data-skill="Provocation" data-state="increase" onclick="toggleSkill('Provocation', 'increase')">üìà</button>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="skill-item">
                                        <span class="skill-name tooltip" data-tooltip="Increase damage done when using Swordsmanship based abilities">Swordsmanship</span>
                                        <div class="skill-controls">
                                            <span class="skill-value" id="skill-swordsmanship">0.0</span>
                                            <div class="toggle-controls">
                                                <button class="toggle-btn" data-skill="Swordsmanship" data-state="decrease" onclick="toggleSkill('Swordsmanship', 'decrease')">üìâ</button>
                                                <button class="toggle-btn" data-skill="Swordsmanship" data-state="lock" onclick="toggleSkill('Swordsmanship', 'lock')">üîí</button>
                                                <button class="toggle-btn" data-skill="Swordsmanship" data-state="increase" onclick="toggleSkill('Swordsmanship', 'increase')">üìà</button>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="skill-item">
                                        <span class="skill-name tooltip" data-tooltip="Increased accuracy with physical based attacks">Combat Tactics</span>
                                        <div class="skill-controls">
                                            <span class="skill-value" id="skill-combattactics">0.0</span>
                                            <div class="toggle-controls">
                                                <button class="toggle-btn" data-skill="CombatTactics" data-state="decrease" onclick="toggleSkill('CombatTactics', 'decrease')">üìâ</button>
                                                <button class="toggle-btn" data-skill="CombatTactics" data-state="lock" onclick="toggleSkill('CombatTactics', 'lock')">üîí</button>
                                                <button class="toggle-btn" data-skill="CombatTactics" data-state="increase" onclick="toggleSkill('CombatTactics', 'increase')">üìà</button>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="skill-item">
                                        <span class="skill-name tooltip" data-tooltip="Increase damage done when using Mace Fighting based abilities">Mace Fighting</span>
                                        <div class="skill-controls">
                                            <span class="skill-value" id="skill-macefighting">0.0</span>
                                            <div class="toggle-controls">
                                                <button class="toggle-btn" data-skill="MaceFighting" data-state="decrease" onclick="toggleSkill('MaceFighting', 'decrease')">üìâ</button>
                                                <button class="toggle-btn" data-skill="MaceFighting" data-state="lock" onclick="toggleSkill('MaceFighting', 'lock')">üîí</button>
                                                <button class="toggle-btn" data-skill="MaceFighting" data-state="increase" onclick="toggleSkill('MaceFighting', 'increase')">üìà</button>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="skill-item">
                                        <span class="skill-name tooltip" data-tooltip="Increase damage done when using Close Combat based abilities">Close Combat</span>
                                        <div class="skill-controls">
                                            <span class="skill-value" id="skill-closecombat">0.0</span>
                                            <div class="toggle-controls">
                                                <button class="toggle-btn" data-skill="CloseCombat" data-state="decrease" onclick="toggleSkill('CloseCombat', 'decrease')">üìâ</button>
                                                <button class="toggle-btn" data-skill="CloseCombat" data-state="lock" onclick="toggleSkill('CloseCombat', 'lock')">üîí</button>
                                                <button class="toggle-btn" data-skill="CloseCombat" data-state="increase" onclick="toggleSkill('CloseCombat', 'increase')">üìà</button>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="skill-item">
                                        <span class="skill-name tooltip" data-tooltip="Increase damage done when using Fire Dominance based abilities">Fire Dominance</span>
                                        <div class="skill-controls">
                                            <span class="skill-value" id="skill-firedominance">0.0</span>
                                            <div class="toggle-controls">
                                                <button class="toggle-btn" data-skill="FireDominance" data-state="decrease" onclick="toggleSkill('FireDominance', 'decrease')">üìâ</button>
                                                <button class="toggle-btn" data-skill="FireDominance" data-state="lock" onclick="toggleSkill('FireDominance', 'lock')">üîí</button>
                                                <button class="toggle-btn" data-skill="FireDominance" data-state="increase" onclick="toggleSkill('FireDominance', 'increase')">üìà</button>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="skill-item">
                                        <span class="skill-name tooltip" data-tooltip="Increase damage done when using Frost Dominance based abilities">Frost Dominance</span>
                                        <div class="skill-controls">
                                            <span class="skill-value" id="skill-frostdominance">0.0</span>
                                            <div class="toggle-controls">
                                                <button class="toggle-btn" data-skill="FrostDominance" data-state="decrease" onclick="toggleSkill('FrostDominance', 'decrease')">üìâ</button>
                                                <button class="toggle-btn" data-skill="FrostDominance" data-state="lock" onclick="toggleSkill('FrostDominance', 'lock')">üîí</button>
                                                <button class="toggle-btn" data-skill="FrostDominance" data-state="increase" onclick="toggleSkill('FrostDominance', 'increase')">üìà</button>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="skill-item">
                                        <span class="skill-name tooltip" data-tooltip="Increase damage done when using Dark Knowledge based abilities">Dark Knowledge</span>
                                        <div class="skill-controls">
                                            <span class="skill-value" id="skill-darkknowledge">0.0</span>
                                            <div class="toggle-controls">
                                                <button class="toggle-btn" data-skill="DarkKnowledge" data-state="decrease" onclick="toggleSkill('DarkKnowledge', 'decrease')">üìâ</button>
                                                <button class="toggle-btn" data-skill="DarkKnowledge" data-state="lock" onclick="toggleSkill('DarkKnowledge', 'lock')">üîí</button>
                                                <button class="toggle-btn" data-skill="DarkKnowledge" data-state="increase" onclick="toggleSkill('DarkKnowledge', 'increase')">üìà</button>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="skill-item">
                                        <span class="skill-name tooltip" data-tooltip="Increase damage done when using Holy Wisdom based abilities">Holy Wisdom</span>
                                        <div class="skill-controls">
                                            <span class="skill-value" id="skill-holywisdom">0.0</span>
                                            <div class="toggle-controls">
                                                <button class="toggle-btn" data-skill="HolyWisdom" data-state="decrease" onclick="toggleSkill('HolyWisdom', 'decrease')">üìâ</button>
                                                <button class="toggle-btn" data-skill="HolyWisdom" data-state="lock" onclick="toggleSkill('HolyWisdom', 'lock')">üîí</button>
                                                <button class="toggle-btn" data-skill="HolyWisdom" data-state="increase" onclick="toggleSkill('HolyWisdom', 'increase')">üìà</button>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="skill-item">
                                        <span class="skill-name tooltip" data-tooltip="Increase accuracy with magical based attacks">Magic Focus</span>
                                        <div class="skill-controls">
                                            <span class="skill-value" id="skill-magicfocus">0.0</span>
                                            <div class="toggle-controls">
                                                <button class="toggle-btn" data-skill="MagicFocus" data-state="decrease" onclick="toggleSkill('MagicFocus', 'decrease')">üìâ</button>
                                                <button class="toggle-btn" data-skill="MagicFocus" data-state="lock" onclick="toggleSkill('MagicFocus', 'lock')">üîí</button>
                                                <button class="toggle-btn" data-skill="MagicFocus" data-state="increase" onclick="toggleSkill('MagicFocus', 'increase')">üìà</button>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="skill-item">
                                        <span class="skill-name tooltip" data-tooltip="Increase chance to crit with magical based attacks">Spirit Control</span>
                                        <div class="skill-controls">
                                            <span class="skill-value" id="skill-spiritcontrol">0.0</span>
                                            <div class="toggle-controls">
                                                <button class="toggle-btn" data-skill="SpiritControl" data-state="decrease" onclick="toggleSkill('SpiritControl', 'decrease')">üìâ</button>
                                                <button class="toggle-btn" data-skill="SpiritControl" data-state="lock" onclick="toggleSkill('SpiritControl', 'lock')">üîí</button>
                                                <button class="toggle-btn" data-skill="SpiritControl" data-state="increase" onclick="toggleSkill('SpiritControl', 'increase')">üìà</button>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="skill-item">
                                        <span class="skill-name tooltip" data-tooltip="Opposite of Provocation, makes it less likely you'll be targeted in group combat">Silent Discipline</span>
                                        <div class="skill-controls">
                                            <span class="skill-value" id="skill-silentdiscipline">0.0</span>
                                            <div class="toggle-controls">
                                                <button class="toggle-btn" data-skill="SilentDiscipline" data-state="decrease" onclick="toggleSkill('SilentDiscipline', 'decrease')">üìâ</button>
                                                <button class="toggle-btn" data-skill="SilentDiscipline" data-state="lock" onclick="toggleSkill('SilentDiscipline', 'lock')">üîí</button>
                                                <button class="toggle-btn" data-skill="SilentDiscipline" data-state="increase" onclick="toggleSkill('SilentDiscipline', 'increase')">üìà</button>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="skill-item">
                                        <span class="skill-name tooltip" data-tooltip="Reduces damage you take from magic based attacks">Magic Resist</span>
                                        <div class="skill-controls">
                                            <span class="skill-value" id="skill-magicresist">0.0</span>
                                            <div class="toggle-controls">
                                                <button class="toggle-btn" data-skill="MagicResist" data-state="decrease" onclick="toggleSkill('MagicResist', 'decrease')">üìâ</button>
                                                <button class="toggle-btn" data-skill="MagicResist" data-state="lock" onclick="toggleSkill('MagicResist', 'lock')">üîí</button>
                                                <button class="toggle-btn" data-skill="MagicResist" data-state="increase" onclick="toggleSkill('MagicResist', 'increase')">üìà</button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="skill-category">
                                <h4>Vitality Skills</h4>
                                <div class="skill-list">
                                    <div class="skill-item">
                                        <span class="skill-name tooltip" data-tooltip="Passively regenerate health at the end of each turn in combat">First Aid</span>
                                        <div class="skill-controls">
                                            <span class="skill-value" id="skill-firstaid">0.0</span>
                                            <div class="toggle-controls">
                                                <button class="toggle-btn" data-skill="FirstAid" data-state="decrease" onclick="toggleSkill('FirstAid', 'decrease')">üìâ</button>
                                                <button class="toggle-btn" data-skill="FirstAid" data-state="lock" onclick="toggleSkill('FirstAid', 'lock')">üîí</button>
                                                <button class="toggle-btn" data-skill="FirstAid" data-state="increase" onclick="toggleSkill('FirstAid', 'increase')">üìà</button>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="skill-item">
                                        <span class="skill-name tooltip" data-tooltip="Restore a percentage of your max health after combat ends">Restoration</span>
                                        <div class="skill-controls">
                                            <span class="skill-value" id="skill-restoration">0.0</span>
                                            <div class="toggle-controls">
                                                <button class="toggle-btn" data-skill="Restoration" data-state="decrease" onclick="toggleSkill('Restoration', 'decrease')">üìâ</button>
                                                <button class="toggle-btn" data-skill="Restoration" data-state="lock" onclick="toggleSkill('Restoration', 'lock')">üîí</button>
                                                <button class="toggle-btn" data-skill="Restoration" data-state="increase" onclick="toggleSkill('Restoration', 'increase')">üìà</button>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="skill-item">
                                        <span class="skill-name tooltip" data-tooltip="Increase your HP based values">Endurance</span>
                                        <div class="skill-controls">
                                            <span class="skill-value" id="skill-endurance">0.0</span>
                                            <div class="toggle-controls">
                                                <button class="toggle-btn" data-skill="Endurance" data-state="decrease" onclick="toggleSkill('Endurance', 'decrease')">üìâ</button>
                                                <button class="toggle-btn" data-skill="Endurance" data-state="lock" onclick="toggleSkill('Endurance', 'lock')">üîí</button>
                                                <button class="toggle-btn" data-skill="Endurance" data-state="increase" onclick="toggleSkill('Endurance', 'increase')">üìà</button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    </div>

                    <!-- Action Buttons -->
                    <div class="character-actions">
                        <button class="btn btn-primary" onclick="showMap()">Explore Map</button>
                        <button class="btn btn-secondary" onclick="showInventory()">View Inventory</button>
                    </div>
                </div>

                <div class="character-controls">
                    <button class="btn btn-secondary" onclick="showWelcome()">Back to Main Menu</button>
                </div>
            </div>
        </div>

        <!-- Map Screen -->
        <div id="map-screen" class="game-container" style="display: none;">
            <div class="welcome">
                <h1>World Map</h1>
                <p>The realm of Pandimus stretches far beyond what the eye can see. From the whispering forests where ancient spirits dwell to the void-touched abyss where reality itself begins to unravel, each location holds its own mysteries and dangers.</p>
                <div class="lore-section" style="margin-top: 1rem; padding: 1rem; background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%); border-radius: 8px; border-left: 4px solid #d4af37; border: 2px solid #8b7355;">
                    <h4 style="color: #8b4513; margin: 0 0 0.5rem 0; text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);">The Layered Realms</h4>
                    <p style="margin: 0; font-size: 0.9rem; color: #2d1b0e; text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.3);">
                        Pandimus exists in layers of reality, each more dangerous than the last. As you grow stronger, deeper realms become accessible, but with greater power comes greater peril. The ancient texts speak of realms beyond even the void, where the very concept of existence begins to break down.
                    </p>
                </div>
            </div>

            <div id="map-content">
                <div class="map-viewport-container">
                    <!-- Map Controls and Info -->
                    <div class="map-controls">
                        <div class="map-info">
                            <div class="map-info-item">
                                <strong>Travel Points:</strong> <span id="map-travel-points">10 / 10</span>
                            </div>
                            <div class="map-info-item">
                                <strong>Position:</strong> <span id="map-player-position">X: 500, Y: 500</span>
                            </div>
                            <div class="map-info-item">
                                <strong>Biome:</strong> <span id="map-current-biome">-</span>
                            </div>
                            <div class="map-info-item">
                                <strong>Zone:</strong> <span id="map-current-zone">-</span>
                            </div>
                            <div class="map-info-item">
                                <strong>Level Req:</strong> <span id="map-level-req">1</span>
                            </div>
                            <div class="map-info-item">
                            </div>
                        </div>
                        <div class="movement-controls">
                            <button onclick="moveOnMap('up')" title="Move Up (W)">‚Üë</button>
                            <button onclick="moveOnMap('up')" style="display: none;"></button>
                            <button onclick="moveOnMap('left')" title="Move Left (A)">‚Üê</button>
                            <button onclick="moveOnMap('down')" title="Move Down (S)">‚Üì</button>
                            <button onclick="moveOnMap('right')" title="Move Right (D)">‚Üí</button>
                            <button onclick="moveOnMap('down')" style="display: none;"></button>
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                            <button class="btn btn-secondary" onclick="centerMapOnPlayer()" title="Center map on player">üìç Center</button>
                            <button class="btn btn-secondary" onclick="zoomMapIn()" title="Zoom in">üîç+</button>
                            <button class="btn btn-secondary" onclick="zoomMapOut()" title="Zoom out">üîç-</button>
                            <button class="btn btn-secondary" data-zoom-level="close" onclick="setMapZoomLevel('close')" title="Close view (20x20)">üîç Close</button>
                            <button class="btn btn-secondary" data-zoom-level="medium" onclick="setMapZoomLevel('medium')" title="Medium view (100x100)">üîç Medium</button>
                            <button class="btn btn-secondary" data-zoom-level="full" onclick="setMapZoomLevel('full')" title="Full map view">üîç Full</button>
                            <button class="btn btn-secondary" id="biome-overlay-toggle" onclick="toggleBiomeOverlays()" title="Toggle biome color overlays">üé® Biomes</button>
                        </div>
                    </div>

                    <!-- Map Grid Container -->
                    <div class="map-grid-container" id="map-grid-container">
                        <canvas id="map-canvas" style="display: block; cursor: crosshair;"></canvas>
                    </div>

                    <!-- Biome Square Information Panel -->
                    <div id="biome-square-panel" class="biome-square-panel" style="display: none; margin-top: 1rem;">
                        <div class="biome-panel-header">
                            <h3 style="color: #8b4513; margin: 0;">Current Location</h3>
                        </div>
                        <div class="biome-panel-content">
                            <div class="biome-info-section">
                                <h4 style="color: #8b4513; margin-bottom: 0.5rem;">Biome Information</h4>
                                <div id="biome-description" class="biome-description">-</div>
                                <div class="biome-stats">
                                    <div><strong>Zone Difficulty:</strong> <span id="biome-zone-difficulty">-</span></div>
                                    <div><strong>Level Requirement:</strong> <span id="biome-level-req">-</span></div>
                                    <div><strong>Distance from Start:</strong> <span id="biome-distance-start">-</span></div>
                                    <div><strong>Nearest Town:</strong> <span id="biome-nearest-town">-</span></div>
                                </div>
                            </div>
                            
                            <div class="biome-enemies-section">
                                <h4 style="color: #8b4513; margin-bottom: 0.5rem;">Enemies (<span id="biome-enemy-count">0</span>/25)</h4>
                                <div id="biome-enemies-list" class="biome-entities-list">
                                    <div class="biome-empty-message">No enemies present</div>
                                </div>
                            </div>
                            
                            <div class="biome-resources-section">
                                <h4 style="color: #8b4513; margin-bottom: 0.5rem;">Resources (<span id="biome-resource-count">0</span>/25)</h4>
                                <div id="biome-resources-list" class="biome-entities-list">
                                    <div class="biome-empty-message">No resources available</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Map Legend -->
                    <div class="map-legend" style="margin-top: 1rem; padding: 1rem; background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%); border: 2px solid #8b7355; border-radius: 8px;">
                        <h4 style="color: #8b4513; margin-bottom: 0.5rem;">Map Legend</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.5rem; font-size: 0.85rem;">
                            <div><span style="display: inline-block; width: 16px; height: 16px; background: #90EE90; border: 1px solid #666; vertical-align: middle; margin-right: 0.5rem;"></span> Plains</div>
                            <div><span style="display: inline-block; width: 16px; height: 16px; background: #228B22; border: 1px solid #666; vertical-align: middle; margin-right: 0.5rem;"></span> Forest</div>
                            <div><span style="display: inline-block; width: 16px; height: 16px; background: #EDC9AF; border: 1px solid #666; vertical-align: middle; margin-right: 0.5rem;"></span> Desert</div>
                            <div><span style="display: inline-block; width: 16px; height: 16px; background: #808080; border: 1px solid #666; vertical-align: middle; margin-right: 0.5rem;"></span> Mountains</div>
                            <div><span style="display: inline-block; width: 16px; height: 16px; background: #2F4F2F; border: 1px solid #666; vertical-align: middle; margin-right: 0.5rem;"></span> Swamp</div>
                            <div><span style="display: inline-block; width: 16px; height: 16px; background: #4682B4; border: 1px solid #666; vertical-align: middle; margin-right: 0.5rem;"></span> Coast</div>
                            <div><span style="display: inline-block; width: 16px; height: 16px; background: #8B0000; border: 1px solid #666; vertical-align: middle; margin-right: 0.5rem;"></span> Volcanic</div>
                            <div><span style="display: inline-block; width: 16px; height: 16px; background: #E0E0E0; border: 1px solid #666; vertical-align: middle; margin-right: 0.5rem;"></span> Tundra</div>
                            <div><span style="display: inline-block; width: 16px; height: 16px; background: #2F4F2F; border: 1px solid #666; vertical-align: middle; margin-right: 0.5rem;"></span> Jungle</div>
                            <div><span style="display: inline-block; width: 16px; height: 16px; background: #CD853F; border: 1px solid #666; vertical-align: middle; margin-right: 0.5rem;"></span> Canyon</div>
                            <div><span style="display: inline-block; width: 16px; height: 16px; background: #FFD700; border: 2px solid #8B4513; vertical-align: middle; margin-right: 0.5rem;"></span> Town</div>
                            <div><span style="display: inline-block; width: 16px; height: 16px; background: #FF0000; border: 2px solid #FFF; vertical-align: middle; margin-right: 0.5rem;"></span> Player</div>
                            <div><span style="display: inline-block; width: 16px; height: 16px; background: #333; border: 1px solid #666; vertical-align: middle; margin-right: 0.5rem;"></span> Unexplored</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Inventory Screen -->
        <div id="inventory-screen" class="game-container" style="display: none;">
            <div class="welcome">
                <h1>Inventory & Crafting</h1>
                <p>The ancient art of crafting in Pandimus is more than mere metalworking. It is the fusion of material and magic, where the crafter's intent becomes reality. Each item you forge carries a piece of your soul, growing stronger as you do.</p>
                <div class="lore-section" style="margin-top: 1rem; padding: 1rem; background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%); border-radius: 8px; border-left: 4px solid #d4af37; border: 2px solid #8b7355;">
                    <h4 style="color: #8b4513; margin: 0 0 0.5rem 0; text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);">The Art of Soul Forging</h4>
                    <p style="margin: 0; font-size: 0.9rem; color: #1a1a1a; text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.3);">
                        True masters of the craft know that the greatest weapons are not forged in fire, but in the crucible of experience. Each battle fought, each challenge overcome, imbues your equipment with greater power. The materials you gather are not mere resources‚Äîthey are fragments of the world's essence, waiting to be shaped by your will.
                    </p>
                </div>
            </div>

            <div class="inventory-tabs">
                <button class="tab-btn active" onclick="showInventoryTab('items')">Items</button>
                <button class="tab-btn" onclick="showInventoryTab('crafting')">Crafting</button>
                <button class="tab-btn" onclick="showInventoryTab('materials')">Materials</button>
                <button class="tab-btn" id="refinement-tab-btn" onclick="showInventoryTab('refinement')" style="display: none;">Refinement</button>
            </div>

            <div id="inventory-content">
                <!-- Items Tab -->
                <div id="items-tab" class="tab-content">
                    <!-- Item Category Filters -->
                    <div class="item-category-tabs" style="display: flex; gap: 0.5rem; margin-bottom: 1rem; flex-wrap: wrap;">
                        <button class="tab-btn" onclick="filterInventoryByCategory('all')" id="filter-all">All</button>
                        <button class="tab-btn" onclick="filterInventoryByCategory('weapon')" id="filter-weapon">Weapons</button>
                        <button class="tab-btn" onclick="filterInventoryByCategory('armor')" id="filter-armor">Armor</button>
                        <button class="tab-btn" onclick="filterInventoryByCategory('accessory')" id="filter-accessory">Accessories</button>
                    </div>
                    
                    <!-- Sort Options -->
                    <div class="sort-options" style="display: flex; gap: 0.5rem; margin-bottom: 1rem; align-items: center; flex-wrap: wrap;">
                        <label style="color: #8b4513; font-weight: bold;">Sort by:</label>
                        <select id="inventory-sort" onchange="sortInventory()" style="padding: 0.5rem; border: 2px solid #8b7355; border-radius: 4px; background: linear-gradient(180deg, #f4e4c1 0%, #e8d5b7 100%); color: #1a1a1a;">
                            <option value="name">Name</option>
                            <option value="power">Power</option>
                            <option value="dexterity">Dexterity</option>
                            <option value="vitality">Vitality</option>
                            <option value="tier">Tier</option>
                            <option value="rarity">Rarity</option>
                        </select>
                        <button class="btn btn-secondary" onclick="sortInventory()" style="padding: 0.5rem 1rem;">Sort</button>
                    </div>
                    
                    <div class="inventory-grid" id="inventory-grid">
                        <!-- Items will be dynamically added here -->
                    </div>
                </div>

                <!-- Crafting Tab -->
                <div id="crafting-tab" class="tab-content" style="display: none;">
                    <div class="crafting-section">
                        <h3>Available Recipes</h3>
                        <div id="crafting-recipes" class="crafting-recipes">
                            <!-- Recipes will be dynamically added here -->
                        </div>
                    </div>
                </div>

                <!-- Materials Tab -->
                <div id="materials-tab" class="tab-content" style="display: none;">
                    <div class="materials-section">
                        <h3>Materials</h3>
                        <div id="materials-display" class="materials-grid">
                            <!-- Materials will be dynamically added here -->
                        </div>
                    </div>
                </div>

                <!-- Refinement Tab -->
                <div id="refinement-tab" class="tab-content" style="display: none;">
                    <div class="refinement-section">
                        <h3>Resource Refinement</h3>
                        <p style="margin-bottom: 1rem; color: #2d1b0e;">Refine raw resources into usable materials. Only available in towns.</p>
                        <div id="refinement-recipes" class="refinement-recipes">
                            <!-- Refinement recipes will be dynamically added here -->
                        </div>
                    </div>
                </div>

                <div class="inventory-controls">
                    <button class="btn btn-secondary" onclick="showWelcome()">Back to Main Menu</button>
                </div>
            </div>
        </div>

        <!-- Combat Screen -->
        <div id="combat-screen" class="game-container" style="display: none;">
            <div class="welcome">
                <h1>Combat Arena</h1>
                <p>In Pandimus, combat is not merely about strength against strength. It is a dance of strategy and will, where every decision carries weight and every victory shapes your destiny. The ancient arts of war teach that true mastery comes not from overwhelming force, but from understanding the flow of battle itself.</p>
                <div class="lore-section" style="margin-top: 1rem; padding: 1rem; background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%); border-radius: 8px; border-left: 4px solid #d4af37; border: 2px solid #8b7355;">
                    <h4 style="color: #8b4513; margin: 0 0 0.5rem 0; text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);">The Dance of Blades</h4>
                    <p style="margin: 0; font-size: 0.9rem; color: #1a1a1a; text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.3);">
                        The greatest warriors of Pandimus speak of combat as a conversation between souls. Each strike is a word, each parry a response, each victory a story told in steel and magic. As you grow in power, you'll learn to read the rhythm of battle, to anticipate your foe's next move, and to turn their strength against them.
                    </p>
                </div>
            </div>

            <div id="combat-content">
                <div class="combat-area">
                    <div class="combatant player">
                        <h3 id="player-name">Player</h3>
                        <div class="health-bar">
                            <div class="health-fill" id="player-health" style="width: 100%"></div>
                        </div>
                        <p>HP: <span id="player-hp-text">100/100</span></p>
                    </div>
                    
                    <div class="vs">
                        <div>VS</div>
                        <div id="turn-counter" style="font-size: 0.8rem; margin-top: 0.5rem; font-weight: bold;">Turn 0/50</div>
                    </div>
                    
                    <div class="combatant enemy">
                        <h3 id="enemy-name">Goblin Warrior</h3>
                        <div class="health-bar">
                            <div class="health-fill enemy-health" id="enemy-health" style="width: 100%"></div>
                        </div>
                        <p>HP: <span id="enemy-hp-text">80/80</span></p>
                    </div>
                </div>

                <div class="combat-actions">
                    <h3>Combat Status</h3>
                    <div class="combat-status">
                        <p><strong>Automatic Combat Active</strong></p>
                        <p>Your character will automatically choose the best actions during combat.</p>
                    </div>
                </div>

                <div class="combat-log" id="combat-log">
                    <h3>Combat Log</h3>
                    <div id="log-content">Combat ready! Automatic combat will begin shortly.</div>
                </div>

                <div class="combat-controls">
                    <div id="idle-combat-info" style="display: none;">
                        <p><strong>Idle Combat Active</strong></p>
                        <p>Battles completed: <span id="battles-completed">0</span></p>
                        <button class="btn btn-secondary" onclick="stopIdleCombat()">Stop Idle Combat</button>
                    </div>
                    <div id="normal-combat-controls">
                        <button class="btn btn-secondary" onclick="showMap()">Back to Map</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Resource Gathering Modal -->
        <div id="resource-gathering-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content" style="max-width: 500px; background: linear-gradient(180deg, #d4c5a9 0%, #c4b599 100%); border: 2px solid #8b7355; border-radius: 8px; padding: 2rem;">
                <h2 style="color: #8b4513; margin-top: 0;">Gather Resources</h2>
                <div id="resource-gathering-info" style="margin-bottom: 1.5rem;">
                    <p style="color: #1a1a1a;"><strong id="resource-gathering-name">Resource</strong></p>
                    <p style="color: #1a1a1a;">Available: <span id="resource-gathering-max">1</span></p>
                </div>
                <div style="margin-bottom: 1.5rem;">
                    <label for="resource-quantity-input" style="display: block; margin-bottom: 0.5rem; color: #1a1a1a; font-weight: bold;">Quantity:</label>
                    <input type="number" id="resource-quantity-input" min="1" value="1" style="width: 100%; padding: 0.5rem; font-size: 1rem; border: 2px solid #8b7355; border-radius: 4px; background: #f5f5dc;">
                    <div style="margin-top: 0.5rem; display: flex; gap: 0.5rem;">
                        <button class="btn btn-secondary" onclick="setResourceQuantity(1)" style="flex: 1;">1</button>
                        <button class="btn btn-secondary" onclick="setResourceQuantity(5)" style="flex: 1;">5</button>
                        <button class="btn btn-secondary" onclick="setResourceQuantity(10)" style="flex: 1;">10</button>
                        <button class="btn btn-secondary" onclick="setResourceQuantityMax()" style="flex: 1;">Max</button>
                    </div>
                </div>
                <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                    <button class="btn btn-secondary" onclick="closeResourceGatheringModal()">Cancel</button>
                    <button class="btn btn-primary" onclick="confirmGatherResource()">Gather</button>
                </div>
            </div>
        </div>

        <!-- Shops Screen -->
        <div id="shops-screen" class="game-container" style="display: none;">
            <div class="welcome">
                <h1>Merchant District</h1>
                <p>Visit specialized vendors to buy, sell, and trade equipment. Complete quests to gain reputation and access better items.</p>
            </div>

            <div class="currency-display">
                <span>üí∞ Gold: <span id="shops-gold">100</span></span>
            </div>

            <div class="shops-grid">
                <div class="shop-card" onclick="showVendorShop('martial')">
                    <div class="shop-icon">‚öîÔ∏è</div>
                    <h3>Blacksmith Thorin</h3>
                    <p>Martial weapons and armor</p>
                    <div class="reputation">Reputation: <span id="martial-rep">0</span></div>
                    <div class="shop-status" id="martial-status">Open</div>
                </div>

                <div class="shop-card" onclick="showVendorShop('magical')">
                    <div class="shop-icon">üîÆ</div>
                    <h3>Enchantress Lyra</h3>
                    <p>Magical weapons and armor</p>
                    <div class="reputation">Reputation: <span id="magical-rep">0</span></div>
                    <div class="shop-status" id="magical-status">Open</div>
                </div>

                <div class="shop-card" onclick="showVendorShop('jewelry')">
                    <div class="shop-icon">üíé</div>
                    <h3>Gemmaster Eldric</h3>
                    <p>Jewelry and accessories</p>
                    <div class="reputation">Reputation: <span id="jewelry-rep">0</span></div>
                    <div class="shop-status" id="jewelry-status">Open</div>
                </div>
            </div>

            <div class="shop-controls">
                <button class="btn btn-secondary" onclick="showWelcome()">Back to Main Menu</button>
            </div>
        </div>

        <!-- Vendor Shop Screen -->
        <div id="vendor-shop-screen" class="game-container" style="display: none;">
            <div class="welcome">
                <h1 id="vendor-title">Vendor Shop</h1>
                <p id="vendor-description">Browse and trade with this specialized merchant.</p>
            </div>

            <div class="shop-layout">
                <div class="shop-sidebar">
                    <div class="vendor-info">
                        <h3 id="vendor-name">Vendor</h3>
                        <p>Reputation: <span id="vendor-reputation">0</span></p>
                        <p>Gold: <span id="vendor-player-gold">100</span></p>
                    </div>
                    
                    <div class="shop-tabs">
                        <button class="tab-btn active" onclick="switchShopTab('buy')">Buy</button>
                        <button class="tab-btn" onclick="switchShopTab('sell')">Sell</button>
                        <button class="tab-btn" onclick="switchShopTab('quests')">Quests</button>
                    </div>
                </div>

                <div class="shop-content">
                    <div id="buy-tab" class="shop-tab active">
                        <h3>Available Items</h3>
                        <div id="vendor-inventory" class="item-grid"></div>
                    </div>

                        <div id="sell-tab" class="shop-tab">
                            <h3>Your Items</h3>
                            <div class="sell-controls">
                                <button class="btn btn-secondary" onclick="sellAllItems()">Sell All</button>
                            </div>
                            <div id="player-sell-items" class="item-grid"></div>
                        </div>

                    <div id="quests-tab" class="shop-tab">
                        <h3>Available Quests</h3>
                        <div id="vendor-quests" class="quest-list"></div>
                    </div>
                </div>
            </div>

            <div class="shop-controls">
                <button class="btn btn-secondary" onclick="showShops()">Back to Shops</button>
            </div>
        </div>
    </main>

    <footer class="footer">
        Built with Electron ‚Ä¢ Pandimus Reborn v1.0.0
    </footer>

    <!-- Import GameEngine module -->
    <script type="module">
        let GameEngineModule = null;
        let GameDataModule = null;
        
        // Try to import modules
        try {
            const engineModule = await import('../../packages/shared/src/game-engine.js');
            const dataModule = await import('../../packages/shared/src/game-data.js');
            
            GameEngineModule = engineModule;
            GameDataModule = dataModule;
            
            // Make available globally
            window.GameEngine = engineModule.GameEngine;
            window.GameData = dataModule.GameData;
            
            console.log('GameEngine modules loaded successfully');
        } catch (error) {
            console.error('Error loading GameEngine modules:', error);
            console.log('Map system will use fallback mode');
        }
        
        // Initialize game engine
        window.gameEngine = null;
        
        // Initialize game engine when needed
        function initializeGameEngine() {
            if (!window.GameEngine) {
                console.warn('GameEngine not available - map features may be limited');
                return null;
            }
            
            if (!window.gameEngine) {
                window.gameEngine = new window.GameEngine();
                
                // Load existing game state if available
                const savedData = localStorage.getItem('pandimusGameData');
                if (savedData) {
                    try {
                        const data = JSON.parse(savedData);
                        if (data.mapPosition) {
                            window.gameEngine.gameState.mapPosition = data.mapPosition;
                        }
                        // Fog of war removed - no need to load explored squares
                        if (data.discoveredTowns) {
                            window.gameEngine.gameState.discoveredTowns = data.discoveredTowns;
                        }
                        if (data.player) {
                            window.gameEngine.gameState.player = data.player;
                        }
                        // Load travel points state
                        if (data.dailyTravelPoints !== undefined) {
                            window.gameEngine.gameState.dailyTravelPoints = data.dailyTravelPoints;
                        }
                        if (data.maxDailyTravelPoints !== undefined) {
                            window.gameEngine.gameState.maxDailyTravelPoints = data.maxDailyTravelPoints;
                        }
                        if (data.lastTravelReset !== undefined) {
                            window.gameEngine.gameState.lastTravelReset = data.lastTravelReset;
                        }
                    } catch (e) {
                        console.error('Error loading game state:', e);
                    }
                }
                
                // Generate map if not already generated
                if (!window.gameEngine.mapGenerated) {
                    window.gameEngine.generateMap();
                }
            }
            return window.gameEngine;
        }
        
        window.initializeGameEngine = initializeGameEngine;
    </script>

    <script>
        // Game state
        let currentScreen = "welcome";
        let player = null;
        let combatState = null;
        let currentLocation = null;
        let battleTurnCount = 0;
        let maxBattleTurns = 50; // Maximum turns before stalemate resolution
        let gameData = {
            player: null,
            inventory: [],
            equipment: {
                // Left column
                helmet: null,
                shoulders: null,
                chest: null,
                bracers: null,
                gloves: null,
                ring1: null,
                ring2: null,
                
                // Right column
                necklace: null,
                cape: null,
                belt: null,
                pants: null,
                boots: null,
                ring3: null,
                ring4: null,
                
                // Bottom row
                mainhand: null,
                offhand: null,
                trinket1: null,
                trinket2: null
            },
            // Prestige system
            prestige: {
                level: 0,
                points: 0,
                totalPrestigePoints: 0,
                bonuses: {
                    attributeMultiplier: 1.0,
                    skillMultiplier: 1.0,
                    experienceMultiplier: 1.0,
                    goldMultiplier: 1.0,
                    dropRateMultiplier: 1.0
                },
                unlockedContent: []
            },
            // Achievement system
            achievements: {
                completed: [],
                progress: {
                    enemiesDefeated: 0,
                    battlesWon: 0,
                    itemsFound: 0,
                    zonesExplored: 0,
                    goldEarned: 0,
                    prestigeLevels: 0,
                    maxTierReached: 0,
                    consecutiveDaysPlayed: 0
                }
            },
            // Crafting system
            crafting: {
                materials: {
                    iron: 0,
                    wood: 0,
                    leather: 0,
                    crystal: 0,
                    dragonScale: 0,
                    voidEssence: 0,
                    celestialShard: 0,
                    nightmareFragment: 0,
                    enhancementStone: 0,
                    magicEssence: 0
                },
                recipes: [],
                unlockedRecipes: []
            },
            // Challenge system
            challenges: {
                daily: {
                    active: null,
                    completed: [],
                    lastReset: Date.now(),
                    streak: 0
                },
                weekly: {
                    active: null,
                    completed: [],
                    lastReset: Date.now(),
                    streak: 0
                }
            },
            // Seasonal content system
            seasonal: {
                currentEvent: null,
                eventStartTime: null,
                eventEndTime: null,
                eventProgress: {},
                unlockedEvents: [],
                seasonalCurrency: 0
            },
            // Meta-progression system
            metaProgression: {
                unlockedModes: ['normal'],
                customization: {
                    characterTheme: 'default',
                    uiTheme: 'default',
                    combatSpeed: 'normal'
                },
                qualityOfLife: {
                    autoEnhancement: false,
                    autoSalvage: false,
                    skipAnimations: false,
                    bulkActions: false
                }
            },
            // Procedural content system
            procedural: {
                dungeons: {
                    currentDungeon: null,
                    completedDungeons: [],
                    dungeonLevel: 1,
                    maxDepth: 0
                },
                infiniteZones: {
                    unlocked: false,
                    currentLevel: 1,
                    maxLevel: 0
                }
            },
        skills: {
            // Power-based skills
            Concentration: 0.0,
            Defense: 0.0,
            Blocking: 0.0,
            Parrying: 0.0,
            Anatomy: 0.0,
            
            // Dexterity-based skills
            Dodging: 0.0,
            FuryControl: 0.0,
            Provocation: 0.0,
            Swordsmanship: 0.0,
            CombatTactics: 0.0,
            MaceFighting: 0.0,
            CloseCombat: 0.0,
            FireDominance: 0.0,
            FrostDominance: 0.0,
            DarkKnowledge: 0.0,
            HolyWisdom: 0.0,
            MagicFocus: 0.0,
            SpiritControl: 0.0,
            SilentDiscipline: 0.0,
            MagicResist: 0.0,
            
            // Vitality-based skills
            FirstAid: 0.0,
            Restoration: 0.0,
            Endurance: 0.0
        },
            // Toggle states for attributes and skills
            attributeToggles: {
                Power: 'lock',
                Dexterity: 'lock',
                Vitality: 'lock'
            },
        skillToggles: {
            // Power-based skills
            Concentration: 'lock',
            Defense: 'lock',
            Blocking: 'lock',
            Parrying: 'lock',
            Anatomy: 'lock',
            
            // Dexterity-based skills
            Dodging: 'lock',
            FuryControl: 'lock',
            Provocation: 'lock',
            Swordsmanship: 'lock',
            CombatTactics: 'lock',
            MaceFighting: 'lock',
            CloseCombat: 'lock',
            FireDominance: 'lock',
            FrostDominance: 'lock',
            DarkKnowledge: 'lock',
            HolyWisdom: 'lock',
            MagicFocus: 'lock',
            SpiritControl: 'lock',
            SilentDiscipline: 'lock',
            MagicResist: 'lock',
            
            // Vitality-based skills
            FirstAid: 'lock',
            Restoration: 'lock',
            Endurance: 'lock'
        },
            // Currency and economy
            currency: {
                gold: 100 // Starting gold
            },
            // Vendor system
            vendors: {
                martial: {
                    name: "Blacksmith Thorin",
                    reputation: 0,
                    lastRotation: Date.now(),
                    inventory: [],
                    quests: []
                },
                magical: {
                    name: "Enchantress Lyra",
                    reputation: 0,
                    lastRotation: Date.now(),
                    inventory: [],
                    quests: []
                },
                jewelry: {
                    name: "Gemmaster Eldric",
                    reputation: 0,
                    lastRotation: Date.now(),
                    inventory: [],
                    quests: []
                }
            },
            // Idle combat system
            idleCombat: {
                isActive: false,
                location: null,
                startTime: null,
                lastSaveTime: null,
                battlesCompleted: 0,
                totalMonstersDefeated: 0,
                offlineProgress: {
                    timeElapsed: 0,
                    battlesCompleted: 0,
                    monstersDefeated: 0,
                    attributeGains: {},
                    skillGains: {},
                    itemsFound: []
                }
            },
            locations: {
                forest: { 
                    name: "Whispering Forest", 
                    difficulty: "beginner", 
                    level: 1,
                    description: "A peaceful forest where new adventurers begin their journey.",
                    enemies: ["Forest Sprite", "Wild Boar", "Moss Wolf"],
                    enemyStats: { hp: 40, power: 15 },
                    uniqueLoot: ["forest"], // Zone-specific loot category
                    recommendedStats: { Power: 50, Dexterity: 50, Vitality: 50 }
                },
                caves: { 
                    name: "Crystal Caves", 
                    difficulty: "intermediate", 
                    level: 2,
                    description: "Glowing crystal formations hide dangerous creatures in the depths.",
                    enemies: ["Crystal Spider", "Cave Bat", "Rock Elemental"],
                    enemyStats: { hp: 70, power: 25 },
                    uniqueLoot: ["crystal"],
                    recommendedStats: { Power: 60, Dexterity: 55, Vitality: 55 }
                },
                ruins: { 
                    name: "Lost Ruins", 
                    difficulty: "advanced", 
                    level: 3,
                    description: "Ancient ruins haunted by the spirits of a forgotten civilization.",
                    enemies: ["Ancient Guardian", "Shadow Wraith", "Corrupted Knight"],
                    enemyStats: { hp: 100, power: 35 },
                    uniqueLoot: ["ancient"],
                    recommendedStats: { Power: 70, Dexterity: 65, Vitality: 60 }
                },
                mountains: { 
                    name: "Dragon Peaks", 
                    difficulty: "expert", 
                    level: 4,
                    description: "The highest peaks where dragons and other legendary creatures dwell.",
                    enemies: ["Young Dragon", "Mountain Troll", "Frost Giant"],
                    enemyStats: { hp: 150, power: 50 },
                    uniqueLoot: ["dragon"],
                    recommendedStats: { Power: 80, Dexterity: 75, Vitality: 70 }
                },
                abyss: { 
                    name: "Shadow Abyss", 
                    difficulty: "master", 
                    level: 5,
                    description: "A dark realm where only the strongest dare to venture.",
                    enemies: ["Void Demon", "Shadow Lord", "Abyssal Horror"],
                    enemyStats: { hp: 200, power: 70 },
                    uniqueLoot: ["abyssal"],
                    recommendedStats: { Power: 90, Dexterity: 85, Vitality: 80 }
                },
                // New Phase 1 Content - Additional Zones
                swamp: { 
                    name: "Murkwood Swamp", 
                    difficulty: "intermediate", 
                    level: 2,
                    description: "A treacherous swamp filled with poisonous creatures and ancient curses.",
                    enemies: ["Swamp Troll", "Poisonous Serpent", "Bog Witch"],
                    enemyStats: { hp: 65, power: 22 },
                    uniqueLoot: ["swamp"],
                    recommendedStats: { Power: 55, Dexterity: 52, Vitality: 53 }
                },
                desert: { 
                    name: "Scorched Sands", 
                    difficulty: "advanced", 
                    level: 3,
                    description: "Endless dunes hide ancient tombs and sand-walking predators.",
                    enemies: ["Sand Wyrm", "Desert Nomad", "Scorpion King"],
                    enemyStats: { hp: 95, power: 32 },
                    uniqueLoot: ["desert"],
                    recommendedStats: { Power: 68, Dexterity: 62, Vitality: 58 }
                },
                volcano: { 
                    name: "Molten Caldera", 
                    difficulty: "expert", 
                    level: 4,
                    description: "The heart of an active volcano where fire elementals reign supreme.",
                    enemies: ["Fire Elemental", "Lava Golem", "Magma Dragon"],
                    enemyStats: { hp: 140, power: 45 },
                    uniqueLoot: ["volcanic"],
                    recommendedStats: { Power: 75, Dexterity: 70, Vitality: 65 }
                },
                frozen: { 
                    name: "Frozen Wastes", 
                    difficulty: "expert", 
                    level: 4,
                    description: "A frozen wasteland where the cold itself is your enemy.",
                    enemies: ["Ice Troll", "Frost Elemental", "Yeti"],
                    enemyStats: { hp: 130, power: 42 },
                    uniqueLoot: ["frozen"],
                    recommendedStats: { Power: 72, Dexterity: 68, Vitality: 70 }
                },
                nightmare: { 
                    name: "Nightmare Realm", 
                    difficulty: "master", 
                    level: 6,
                    description: "A realm where reality bends and nightmares become real.",
                    enemies: ["Nightmare Stalker", "Dream Eater", "Reality Breaker"],
                    enemyStats: { hp: 250, power: 85 },
                    uniqueLoot: ["nightmare"],
                    recommendedStats: { Power: 100, Dexterity: 95, Vitality: 90 }
                },
                celestial: { 
                    name: "Celestial Spire", 
                    difficulty: "legendary", 
                    level: 7,
                    description: "A tower reaching into the heavens, guarded by divine beings.",
                    enemies: ["Celestial Guardian", "Star Seraph", "Cosmic Titan"],
                    enemyStats: { hp: 350, power: 120 },
                    uniqueLoot: ["celestial"],
                    recommendedStats: { Power: 120, Dexterity: 115, Vitality: 110 }
                },
                void: { 
                    name: "Void Nexus", 
                    difficulty: "legendary", 
                    level: 8,
                    description: "The center of all nothingness, where existence itself is challenged.",
                    enemies: ["Void Walker", "Null Entity", "Existence Ender"],
                    enemyStats: { hp: 500, power: 150 },
                    uniqueLoot: ["void"],
                    recommendedStats: { Power: 150, Dexterity: 140, Vitality: 135 }
                }
            }
        };

        // Comprehensive item system with proper vendor classification
        // All available skills for random generation
        const allSkills = [
            'Concentration', 'Defense', 'Blocking', 'Parrying', 'Anatomy',
            'Dodging', 'FuryControl', 'Provocation', 'Swordsmanship', 'CombatTactics', 'MaceFighting', 'CloseCombat', 
            'FireDominance', 'FrostDominance', 'DarkKnowledge', 'HolyWisdom', 'MagicFocus', 'SpiritControl', 
            'SilentDiscipline', 'MagicResist', 'FirstAid', 'Restoration', 'Endurance'
        ];

        // Generate item with randomized skill bonuses
    function generateRandomItem(baseItem) {
        const item = { ...baseItem };
        item.id = Date.now() + Math.random(); // Unique ID
        item.stats = item.stats || {}; // Initialize stats if not present
        item.skills = {};
        item.skillRequirements = {};
        
        // Add randomized attributes (Power, Dexterity, Vitality)
        // Each item can have 0-3 attributes, with values based on tier
        const attributeChance = 0.6; // 60% chance for each attribute
        const attributePoints = baseItem.tier * 3; // Tier 1 = 3 points, Tier 5 = 15 points
        
        if (Math.random() < attributeChance) {
            item.stats.Power = Math.floor(Math.random() * attributePoints) + 1;
        }
        if (Math.random() < attributeChance) {
            item.stats.Dexterity = Math.floor(Math.random() * attributePoints) + 1;
        }
        if (Math.random() < attributeChance) {
            item.stats.Vitality = Math.floor(Math.random() * attributePoints) + 1;
        }
        
        // Determine total skill points available based on tier
        const totalSkillPoints = baseItem.tier * 10; // Tier 1 = 10 total, Tier 5 = 50 total
        
        // Determine number of skills (1-5 skills max)
        const maxSkills = Math.min(baseItem.tier + 1, 5);
        const skillCount = Math.floor(Math.random() * maxSkills) + 1;
        
        // Determine primary skill requirement based on item type
        let primarySkill = null;
        const itemName = item.name.toLowerCase();
        
        if (itemName.includes('sword') || itemName.includes('blade')) {
            primarySkill = 'Swordsmanship';
        } else if (itemName.includes('mace') || itemName.includes('hammer')) {
            primarySkill = 'MaceFighting';
        } else if (itemName.includes('dagger') || itemName.includes('spear')) {
            primarySkill = 'CloseCombat';
        } else if (itemName.includes('fire') && itemName.includes('staff')) {
            primarySkill = 'FireDominance';
        } else if (itemName.includes('frost') && itemName.includes('staff')) {
            primarySkill = 'FrostDominance';
        } else if (itemName.includes('dark') && itemName.includes('staff')) {
            primarySkill = 'DarkKnowledge';
        } else if (itemName.includes('holy') && itemName.includes('staff')) {
            primarySkill = 'HolyWisdom';
        } else if (itemName.includes('shield')) {
            primarySkill = 'Blocking';
        }
        
        // Set primary skill requirement if applicable
        if (primarySkill) {
            item.skillRequirements[primarySkill] = Math.max(1, baseItem.tier * 5 + Math.floor(Math.random() * 10));
        }
        
        // Distribute skill points among selected skills
        const selectedSkills = [];
        let remainingPoints = totalSkillPoints;
        
        // Add primary skill to item skills if it exists
        if (primarySkill) {
            const primaryPoints = Math.min(remainingPoints, Math.floor(totalSkillPoints * 0.4) + Math.floor(Math.random() * 5));
            item.skills[primarySkill] = primaryPoints;
            selectedSkills.push(primarySkill);
            remainingPoints -= primaryPoints;
        }
        
        // Select additional random skills
        const availableSkills = allSkills.filter(skill => skill !== primarySkill);
        while (selectedSkills.length < skillCount && remainingPoints > 0 && selectedSkills.length < allSkills.length) {
            const skill = availableSkills[Math.floor(Math.random() * availableSkills.length)];
            if (!selectedSkills.includes(skill)) {
                selectedSkills.push(skill);
                
                // Distribute remaining points (more points to earlier skills)
                let pointsForThisSkill;
                if (selectedSkills.length === skillCount) {
                    // Last skill gets all remaining points
                    pointsForThisSkill = remainingPoints;
                } else {
                    // Distribute remaining points randomly
                    const maxPoints = Math.min(remainingPoints, Math.floor(remainingPoints / (skillCount - selectedSkills.length + 1)) + 3);
                    pointsForThisSkill = Math.floor(Math.random() * maxPoints) + 1;
                }
                
                item.skills[skill] = pointsForThisSkill;
                remainingPoints -= pointsForThisSkill;
            }
        }
        
        // Ensure we don't have negative remaining points
        if (remainingPoints > 0 && selectedSkills.length > 0) {
            // Add remaining points to a random skill
            const randomSkill = selectedSkills[Math.floor(Math.random() * selectedSkills.length)];
            item.skills[randomSkill] = (item.skills[randomSkill] || 0) + remainingPoints;
        }
        
        return item;
    }

    // Generate descriptive item name with skill information
    function generateItemDisplayName(item) {
        if (!item.skills || Object.keys(item.skills).length === 0) {
            return item.name;
        }
        
        const skills = Object.entries(item.skills)
            .sort((a, b) => b[1] - a[1]) // Sort by skill value descending
            .slice(0, 3) // Take top 3 skills
            .map(([skill, value]) => `${skill}: ${value}`)
            .join(', ');
        
        return `${item.name} (${skills})`;
    }

    // Generate detailed tooltip for items
    function generateItemTooltip(item) {
        let tooltip = `<strong>${item.name}</strong><br>`;
                tooltip += `<span style="color: #d4af37;">${item.rarity.toUpperCase()}</span><br>`;
        
        if (item.stats && Object.keys(item.stats).length > 0) {
            tooltip += '<br><strong>Stats:</strong><br>';
            Object.entries(item.stats).forEach(([stat, value]) => {
                tooltip += `${stat}: +${value}<br>`;
            });
        }
        
        if (item.skills && Object.keys(item.skills).length > 0) {
            tooltip += '<br><strong>Skills:</strong><br>';
            Object.entries(item.skills)
                .sort((a, b) => b[1] - a[1])
                .forEach(([skill, value]) => {
                    tooltip += `${skill}: +${value}<br>`;
                });
        }
        
        if (item.skillRequirements && Object.keys(item.skillRequirements).length > 0) {
            tooltip += '<br><strong>Requirements:</strong><br>';
            Object.entries(item.skillRequirements).forEach(([skill, value]) => {
                const totalSkills = calculateTotalSkills();
                const current = totalSkills[skill] || 0;
                const color = current >= value ? '#4ade80' : '#ef4444';
                tooltip += `<span style="color: ${color};">${skill}: ${current}/${value}</span><br>`;
            });
        }
        
        tooltip += `<br><strong>Value:</strong> ${item.value} gold`;
        
        return tooltip;
    }

    // Update inventory display with tooltips and skill information
    function updateInventoryDisplay() {
        const grid = document.getElementById('inventory-grid');
        if (!grid) return;
        
        grid.innerHTML = '';
        
        if (gameData.inventory.length === 0) {
            grid.innerHTML = '<p>No items in inventory.</p>';
            return;
        }
        
        gameData.inventory.forEach(item => {
            const itemElement = document.createElement('div');
            itemElement.className = 'item-card';
            itemElement.title = generateItemTooltip(item);
            
            const displayName = generateItemDisplayName(item);
            
            itemElement.innerHTML = `
                <div class="item-name">${displayName}</div>
                <div class="item-stats">
                    <span style="color: #d4af37;">${item.rarity.toUpperCase()}</span>
                </div>
                <button class="btn btn-primary" onclick="equipItem('${item.id}')">Equip</button>
            `;
            grid.appendChild(itemElement);
        });
    }

        // Base item templates for generating random drops
        const baseItems = [
            // VENDOR ITEMS (Tier 1)
            { name: "Iron Sword", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 5 }, rarity: "common", value: 20, tier: 1, zones: ["vendor"] },
            { name: "Iron Mace", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 5 }, rarity: "common", value: 20, tier: 1, zones: ["vendor"] },
            { name: "Iron Dagger", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 4, Dexterity: 1 }, rarity: "common", value: 18, tier: 1, zones: ["vendor"] },
            { name: "Fire Staff", type: "weapon", slot: "mainhand", category: "magical", stats: { Power: 4, Dexterity: 2 }, rarity: "common", value: 22, tier: 1, zones: ["vendor"] },
            { name: "Wooden Shield", type: "armor", slot: "offhand", category: "martial", stats: { Vitality: 3 }, rarity: "common", value: 15, tier: 1, zones: ["vendor"] },
            { name: "Leather Helmet", type: "armor", slot: "helmet", category: "martial", stats: { Vitality: 2 }, rarity: "common", value: 12, tier: 1, zones: ["vendor"] },
            { name: "Leather Chest", type: "armor", slot: "chest", category: "martial", stats: { Vitality: 4 }, rarity: "common", value: 18, tier: 1, zones: ["vendor"] },
            { name: "Simple Ring", type: "accessory", slot: "ring", category: "jewelry", stats: { Power: 2 }, rarity: "common", value: 25, tier: 1, zones: ["vendor"] },
            { name: "Basic Necklace", type: "accessory", slot: "necklace", category: "jewelry", stats: { Dexterity: 2 }, rarity: "common", value: 25, tier: 1, zones: ["vendor"] },

            // FOREST ZONE (Tier 1-2) - Complete equipment set
            { name: "Forest Blade", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 8 }, rarity: "common", value: 35, tier: 1, zones: ["forest"] },
            { name: "Forest Mace", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 8 }, rarity: "common", value: 35, tier: 1, zones: ["forest"] },
            { name: "Wooden Spear", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 7, Dexterity: 1 }, rarity: "common", value: 32, tier: 1, zones: ["forest"] },
            { name: "Frost Staff", type: "weapon", slot: "mainhand", category: "magical", stats: { Power: 6, Dexterity: 3 }, rarity: "common", value: 40, tier: 1, zones: ["forest"] },
            { name: "Bark Shield", type: "armor", slot: "offhand", category: "martial", stats: { Vitality: 5 }, rarity: "common", value: 25, tier: 1, zones: ["forest"] },
            { name: "Moss Helmet", type: "armor", slot: "helmet", category: "martial", stats: { Vitality: 4 }, rarity: "common", value: 20, tier: 1, zones: ["forest"] },
            { name: "Forest Shoulders", type: "armor", slot: "shoulders", category: "martial", stats: { Vitality: 3, Power: 1 }, rarity: "common", value: 22, tier: 1, zones: ["forest"] },
            { name: "Forest Tunic", type: "armor", slot: "chest", category: "martial", stats: { Vitality: 6, Power: 2 }, rarity: "common", value: 28, tier: 1, zones: ["forest"] },
            { name: "Forest Bracers", type: "armor", slot: "bracers", category: "martial", stats: { Dexterity: 3, Power: 1 }, rarity: "common", value: 20, tier: 1, zones: ["forest"] },
            { name: "Forest Gloves", type: "armor", slot: "gloves", category: "martial", stats: { Dexterity: 2, Power: 1 }, rarity: "common", value: 18, tier: 1, zones: ["forest"] },
            { name: "Forest Leggings", type: "armor", slot: "pants", category: "martial", stats: { Vitality: 4, Dexterity: 2 }, rarity: "common", value: 24, tier: 1, zones: ["forest"] },
            { name: "Leaf Boots", type: "armor", slot: "boots", category: "martial", stats: { Dexterity: 3 }, rarity: "common", value: 18, tier: 1, zones: ["forest"] },
            { name: "Forest Cloak", type: "armor", slot: "cape", category: "martial", stats: { Dexterity: 4 }, rarity: "common", value: 30, tier: 1, zones: ["forest"] },
            { name: "Forest Belt", type: "armor", slot: "belt", category: "martial", stats: { Vitality: 3, Power: 1 }, rarity: "common", value: 22, tier: 1, zones: ["forest"] },
            { name: "Nature's Ring", type: "accessory", slot: "ring", category: "jewelry", stats: { Vitality: 4 }, rarity: "uncommon", value: 45, tier: 2, zones: ["forest"] },
            { name: "Druid's Necklace", type: "accessory", slot: "necklace", category: "jewelry", stats: { Power: 3, Vitality: 3 }, rarity: "uncommon", value: 50, tier: 2, zones: ["forest"] },
            { name: "Forest Trinket", type: "accessory", slot: "trinket", category: "jewelry", stats: { Dexterity: 3, Power: 2 }, rarity: "uncommon", value: 40, tier: 2, zones: ["forest"] },
            
            // FOREST ZONE - Super Rare Unique Drops (0.001% = 0.00001 chance)
            { name: "Ancient Guardian's Blade", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 25, Dexterity: 10, Vitality: 5 }, rarity: "mythic", value: 5000, tier: 5, zones: ["forest"], isUnique: true, uniqueDropChance: 0.00001 },
            { name: "Nature's Embrace", type: "armor", slot: "chest", category: "magical", stats: { Power: 15, Dexterity: 12, Vitality: 20 }, rarity: "mythic", value: 6000, tier: 5, zones: ["forest"], isUnique: true, uniqueDropChance: 0.00001 },
            { name: "Druid King's Crown", type: "armor", slot: "helmet", category: "magical", stats: { Power: 12, Dexterity: 10, Vitality: 15 }, rarity: "mythic", value: 5500, tier: 5, zones: ["forest"], isUnique: true, uniqueDropChance: 0.00001 },

            // CRYSTAL CAVES (Tier 2-3)
            { name: "Crystal Sword", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 12, Dexterity: 2 }, rarity: "uncommon", value: 80, tier: 2, zones: ["crystal"] },
            { name: "Crystal Mace", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 12, Dexterity: 2 }, rarity: "uncommon", value: 80, tier: 2, zones: ["crystal"] },
            { name: "Crystal Dagger", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 10, Dexterity: 4 }, rarity: "uncommon", value: 75, tier: 2, zones: ["crystal"] },
            { name: "Dark Staff", type: "weapon", slot: "mainhand", category: "magical", stats: { Power: 10, Dexterity: 4 }, rarity: "uncommon", value: 85, tier: 2, zones: ["crystal"] },
            { name: "Crystal Shield", type: "armor", slot: "offhand", category: "martial", stats: { Vitality: 8, Power: 2 }, rarity: "uncommon", value: 70, tier: 2, zones: ["crystal"] },
            { name: "Crystal Helmet", type: "armor", slot: "helmet", category: "martial", stats: { Vitality: 6, Power: 2 }, rarity: "uncommon", value: 60, tier: 2, zones: ["crystal"] },
            { name: "Crystal Chest", type: "armor", slot: "chest", category: "martial", stats: { Vitality: 8, Power: 3 }, rarity: "uncommon", value: 75, tier: 2, zones: ["crystal"] },
            { name: "Crystal Boots", type: "armor", slot: "boots", category: "martial", stats: { Dexterity: 5, Power: 2 }, rarity: "uncommon", value: 55, tier: 2, zones: ["crystal"] },
            { name: "Crystalline Ring", type: "accessory", slot: "ring", category: "jewelry", stats: { Power: 6, Dexterity: 3 }, rarity: "rare", value: 100, tier: 3, zones: ["crystal"] },

            // ANCIENT RUINS (Tier 3-4)
            { name: "Ancient Blade", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 18, Vitality: 3 }, rarity: "rare", value: 150, tier: 3, zones: ["ancient"] },
            { name: "Ancient Hammer", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 18, Vitality: 3 }, rarity: "rare", value: 150, tier: 3, zones: ["ancient"] },
            { name: "Ancient Spear", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 16, Dexterity: 5 }, rarity: "rare", value: 145, tier: 3, zones: ["ancient"] },
            { name: "Holy Staff", type: "weapon", slot: "mainhand", category: "magical", stats: { Power: 15, Dexterity: 6 }, rarity: "rare", value: 160, tier: 3, zones: ["ancient"] },
            { name: "Ancient Shield", type: "armor", slot: "offhand", category: "martial", stats: { Vitality: 12, Power: 4 }, rarity: "rare", value: 130, tier: 3, zones: ["ancient"] },
            { name: "Rune Helmet", type: "armor", slot: "helmet", category: "magical", stats: { Power: 8, Dexterity: 4 }, rarity: "rare", value: 110, tier: 3, zones: ["ancient"] },
            { name: "Ancient Robe", type: "armor", slot: "chest", category: "magical", stats: { Power: 12, Dexterity: 6 }, rarity: "rare", value: 140, tier: 3, zones: ["ancient"] },
            { name: "Guardian's Ring", type: "accessory", slot: "ring", category: "jewelry", stats: { Power: 10, Vitality: 6, Dexterity: 4 }, rarity: "epic", value: 200, tier: 4, zones: ["ancient"] },

            // DRAGON PEAKS (Tier 4-5)
            { name: "Dragon Slayer", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 25, Dexterity: 5 }, rarity: "epic", value: 300, tier: 4, zones: ["dragon"] },
            { name: "Dragon Mace", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 25, Dexterity: 5 }, rarity: "epic", value: 300, tier: 4, zones: ["dragon"] },
            { name: "Dragon Spear", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 23, Dexterity: 7 }, rarity: "epic", value: 295, tier: 4, zones: ["dragon"] },
            { name: "Dragon Scale Shield", type: "armor", slot: "offhand", category: "martial", stats: { Vitality: 18, Power: 6 }, rarity: "epic", value: 250, tier: 4, zones: ["dragon"] },
            { name: "Dragon Helmet", type: "armor", slot: "helmet", category: "martial", stats: { Power: 12, Vitality: 8 }, rarity: "epic", value: 200, tier: 4, zones: ["dragon"] },
            { name: "Dragon Scale Armor", type: "armor", slot: "chest", category: "martial", stats: { Vitality: 20, Power: 8 }, rarity: "epic", value: 280, tier: 4, zones: ["dragon"] },
            { name: "Dragon's Eye", type: "accessory", slot: "ring", category: "jewelry", stats: { Power: 15, Dexterity: 10, Vitality: 8 }, rarity: "legendary", value: 400, tier: 5, zones: ["dragon"] },

            // SHADOW ABYSS (Tier 5)
            { name: "Void Reaper", type: "weapon", slot: "mainhand", category: "magical", stats: { Power: 30, Dexterity: 10 }, rarity: "legendary", value: 500, tier: 5, zones: ["abyssal"] },
            { name: "Shadow Blade", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 28, Dexterity: 12 }, rarity: "legendary", value: 480, tier: 5, zones: ["abyssal"] },
            { name: "Void Hammer", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 28, Dexterity: 12 }, rarity: "legendary", value: 480, tier: 5, zones: ["abyssal"] },
            { name: "Abyssal Spear", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 26, Dexterity: 14 }, rarity: "legendary", value: 470, tier: 5, zones: ["abyssal"] },
            { name: "Void Shield", type: "armor", slot: "offhand", category: "magical", stats: { Power: 15, Vitality: 20 }, rarity: "legendary", value: 400, tier: 5, zones: ["abyssal"] },
            { name: "Shadow Crown", type: "armor", slot: "helmet", category: "magical", stats: { Power: 18, Dexterity: 12 }, rarity: "legendary", value: 350, tier: 5, zones: ["abyssal"] },
            { name: "Void Robe", type: "armor", slot: "chest", category: "magical", stats: { Power: 25, Dexterity: 15 }, rarity: "legendary", value: 450, tier: 5, zones: ["abyssal"] },
            { name: "Abyssal Ring", type: "accessory", slot: "ring", category: "jewelry", stats: { Power: 20, Dexterity: 15, Vitality: 10 }, rarity: "legendary", value: 600, tier: 5, zones: ["abyssal"] },

            // NEW ZONE ITEMS - Phase 1 Content Expansion
            // SWAMP ZONE (Tier 2)
            { name: "Swamp Blade", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 10, Dexterity: 2 }, rarity: "common", value: 45, tier: 2, zones: ["swamp"] },
            { name: "Poison Staff", type: "weapon", slot: "mainhand", category: "magical", stats: { Power: 8, Dexterity: 4 }, rarity: "uncommon", value: 55, tier: 2, zones: ["swamp"] },
            { name: "Bog Armor", type: "armor", slot: "chest", category: "martial", stats: { Vitality: 8, Dexterity: 2 }, rarity: "common", value: 40, tier: 2, zones: ["swamp"] },
            { name: "Swamp Boots", type: "armor", slot: "boots", category: "martial", stats: { Dexterity: 5, Vitality: 3 }, rarity: "common", value: 35, tier: 2, zones: ["swamp"] },

            // DESERT ZONE (Tier 3)
            { name: "Desert Scimitar", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 12, Dexterity: 3 }, rarity: "uncommon", value: 60, tier: 3, zones: ["desert"] },
            { name: "Sand Staff", type: "weapon", slot: "mainhand", category: "magical", stats: { Power: 10, Dexterity: 5 }, rarity: "uncommon", value: 70, tier: 3, zones: ["desert"] },
            { name: "Desert Cloak", type: "armor", slot: "cape", category: "martial", stats: { Dexterity: 6, Vitality: 4 }, rarity: "uncommon", value: 50, tier: 3, zones: ["desert"] },
            { name: "Nomad Ring", type: "accessory", slot: "ring", category: "jewelry", stats: { Power: 6, Dexterity: 4 }, rarity: "uncommon", value: 80, tier: 3, zones: ["desert"] },

            // VOLCANO ZONE (Tier 4)
            { name: "Magma Blade", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 18, Dexterity: 4 }, rarity: "rare", value: 120, tier: 4, zones: ["volcanic"] },
            { name: "Fire Staff", type: "weapon", slot: "mainhand", category: "magical", stats: { Power: 16, Dexterity: 8 }, rarity: "rare", value: 140, tier: 4, zones: ["volcanic"] },
            { name: "Lava Armor", type: "armor", slot: "chest", category: "martial", stats: { Power: 8, Vitality: 12 }, rarity: "rare", value: 150, tier: 4, zones: ["volcanic"] },
            { name: "Volcanic Gauntlets", type: "armor", slot: "gloves", category: "martial", stats: { Power: 6, Dexterity: 4 }, rarity: "rare", value: 100, tier: 4, zones: ["volcanic"] },

            // FROZEN ZONE (Tier 4)
            { name: "Ice Blade", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 16, Dexterity: 6 }, rarity: "rare", value: 130, tier: 4, zones: ["frozen"] },
            { name: "Frost Staff", type: "weapon", slot: "mainhand", category: "magical", stats: { Power: 14, Dexterity: 10 }, rarity: "rare", value: 150, tier: 4, zones: ["frozen"] },
            { name: "Ice Armor", type: "armor", slot: "chest", category: "martial", stats: { Vitality: 14, Dexterity: 6 }, rarity: "rare", value: 160, tier: 4, zones: ["frozen"] },
            { name: "Frozen Boots", type: "armor", slot: "boots", category: "martial", stats: { Dexterity: 8, Vitality: 6 }, rarity: "rare", value: 110, tier: 4, zones: ["frozen"] },

            // NIGHTMARE ZONE (Tier 6)
            { name: "Nightmare Blade", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 25, Dexterity: 8 }, rarity: "epic", value: 250, tier: 6, zones: ["nightmare"] },
            { name: "Dream Staff", type: "weapon", slot: "mainhand", category: "magical", stats: { Power: 22, Dexterity: 12 }, rarity: "epic", value: 280, tier: 6, zones: ["nightmare"] },
            { name: "Shadow Armor", type: "armor", slot: "chest", category: "magical", stats: { Power: 12, Dexterity: 10, Vitality: 8 }, rarity: "epic", value: 300, tier: 6, zones: ["nightmare"] },
            { name: "Nightmare Ring", type: "accessory", slot: "ring", category: "jewelry", stats: { Power: 15, Dexterity: 10, Vitality: 8 }, rarity: "epic", value: 350, tier: 6, zones: ["nightmare"] },

            // CELESTIAL ZONE (Tier 7)
            { name: "Celestial Blade", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 35, Dexterity: 12 }, rarity: "legendary", value: 500, tier: 7, zones: ["celestial"] },
            { name: "Star Staff", type: "weapon", slot: "mainhand", category: "magical", stats: { Power: 32, Dexterity: 18 }, rarity: "legendary", value: 550, tier: 7, zones: ["celestial"] },
            { name: "Divine Armor", type: "armor", slot: "chest", category: "magical", stats: { Power: 18, Dexterity: 15, Vitality: 12 }, rarity: "legendary", value: 600, tier: 7, zones: ["celestial"] },
            { name: "Celestial Crown", type: "armor", slot: "helmet", category: "magical", stats: { Power: 15, Dexterity: 12, Vitality: 10 }, rarity: "legendary", value: 700, tier: 7, zones: ["celestial"] },

            // VOID ZONE (Tier 8)
            { name: "Void Blade", type: "weapon", slot: "mainhand", category: "martial", stats: { Power: 50, Dexterity: 18 }, rarity: "mythic", value: 1000, tier: 8, zones: ["void"] },
            { name: "Null Staff", type: "weapon", slot: "mainhand", category: "magical", stats: { Power: 45, Dexterity: 25 }, rarity: "mythic", value: 1100, tier: 8, zones: ["void"] },
            { name: "Void Armor", type: "armor", slot: "chest", category: "magical", stats: { Power: 25, Dexterity: 20, Vitality: 18 }, rarity: "mythic", value: 1200, tier: 8, zones: ["void"] },
            { name: "Existence Ring", type: "accessory", slot: "ring", category: "jewelry", stats: { Power: 25, Dexterity: 20, Vitality: 15 }, rarity: "mythic", value: 1500, tier: 8, zones: ["void"] }
        ];

        // Generate sampleItems from baseItems for consistent system
        const sampleItems = baseItems.map((baseItem, index) => {
            const item = generateRandomItem(baseItem);
            item.id = index + 1; // Set sequential IDs for consistency
            return item;
        });

        // Screen navigation
        // Current inventory filter and sort
        let currentInventoryFilter = 'all';
        let currentInventorySort = 'name';
        
        function showScreen(screenId) {
            document.querySelectorAll('[id$="-screen"]').forEach(screen => {
                screen.style.display = 'none';
            });
            
            document.getElementById(screenId + '-screen').style.display = 'block';
            currentScreen = screenId;
            
            // Update sidebar navigation highlighting
            document.querySelectorAll('.sidebar-nav button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const navButtonMap = {
                'welcome': 'nav-welcome',
                'character': 'nav-character',
                'map': 'nav-map',
                'inventory': 'nav-inventory',
                'encounters': 'nav-encounters',
                'shops': 'nav-shops',
                'combat': 'nav-encounters' // Combat screen uses encounters nav button
            };
            
            if (navButtonMap[screenId]) {
                const navBtn = document.getElementById(navButtonMap[screenId]);
                if (navBtn) {
                    navBtn.classList.add('active');
                }
            }
        }

        function showWelcome() {
            showScreen('welcome');
        }

        function showCharacter() {
            showScreen('character');
            
            // Try to load saved data first
            if (!player) {
                loadGameData();
            }
            
            updateCharacterDisplay();
            updateToggleButtons(); // Ensure toggle buttons are updated
            
            // Ensure name input is enabled and focused when showing character screen
            setTimeout(() => {
                const nameInput = document.getElementById('char-name-input');
                if (nameInput) {
                    // Remove any disabled/readonly attributes
                    nameInput.disabled = false;
                    nameInput.readOnly = false;
                    nameInput.removeAttribute('disabled');
                    nameInput.removeAttribute('readonly');
                    
                    // Focus the input if no character exists
                    const noCharSection = document.getElementById('no-character-section');
                    if (noCharSection && noCharSection.style.display !== 'none') {
                        nameInput.focus();
                        nameInput.select();
                    }
                }
            }, 100);
        }

        // Map rendering system
        let mapZoom = 1;
        let mapViewportX = 500;
        let mapViewportY = 500;
        let mapCanvas = null;
        let mapCtx = null;
        const MAP_SQUARE_SIZE = 4; // Size of each square in pixels
        const MAP_GRID_SIZE = 1000; // Total grid size (1000x1000 squares)
        
        // Zoom levels: 'close' (20x20), 'medium' (100x100), 'full' (entire map)
        let mapZoomLevel = 'medium'; // Default to medium view
        const ZOOM_LEVELS = {
            close: { size: 20, label: 'Close (20x20)' },
            medium: { size: 100, label: 'Medium (100x100)' },
            full: { size: 1000, label: 'Full Map' }
        };
        
        // Map image
        let mapImage = null;
        let mapImageLoaded = false;
        // Try multiple paths for Electron compatibility
        const MAP_IMAGE_PATH = '../assets/map/world_map.png'; // Relative to apps/desktop/
        let showBiomeOverlays = false; // Toggle for biome color overlays (off by default to show map image)

        let mapKeyHandlerAttached = false;
        
        function initializeMapRenderer() {
            mapCanvas = document.getElementById('map-canvas');
            if (!mapCanvas) return;
            
            mapCtx = mapCanvas.getContext('2d');
            
            // Set canvas size to fill container
            const container = document.getElementById('map-grid-container');
            if (container) {
                // Use container's actual size instead of fixed viewport size
                const rect = container.getBoundingClientRect();
                mapCanvas.width = rect.width || 800;
                mapCanvas.height = rect.height || 600;
                // Also set CSS size to match
                mapCanvas.style.width = mapCanvas.width + 'px';
                mapCanvas.style.height = mapCanvas.height + 'px';
            }
            
            // Load map image
            if (!mapImage) {
                mapImage = new Image();
                mapImage.onload = function() {
                    mapImageLoaded = true;
                    console.log('Map image loaded successfully', mapImage.width, 'x', mapImage.height);
                    // Re-render when image loads
                    if (currentScreen === 'map') {
                        renderMap();
                    }
                };
                mapImage.onerror = function(err) {
                    console.error('Failed to load map image:', MAP_IMAGE_PATH, err);
                    console.error('Trying alternative paths...');
                    mapImageLoaded = false;
                    
                    // Try alternative paths for Electron
                    const alternativePaths = [
                        '../assets/map/world_map.png', // From apps/desktop/
                        '../../assets/map/world_map.png', // From root
                        './assets/map/world_map.png', // Same directory
                        'assets/map/world_map.png' // Root relative
                    ];
                    
                    let pathIndex = 0;
                    const tryNextPath = () => {
                        if (pathIndex < alternativePaths.length) {
                            const altPath = alternativePaths[pathIndex];
                            console.log('Trying alternative path:', altPath);
                            const testImg = new Image();
                            testImg.onload = function() {
                                console.log('Successfully loaded from:', altPath);
                                mapImage.src = altPath;
                                mapImageLoaded = true;
                                if (currentScreen === 'map') {
                                    renderMap();
                                }
                            };
                            testImg.onerror = function() {
                                pathIndex++;
                                tryNextPath();
                            };
                            testImg.src = altPath;
                        } else {
                            console.error('Could not load map image from any path');
                        }
                    };
                    tryNextPath();
                };
                
                // Try loading the image
                console.log('Loading map image from:', MAP_IMAGE_PATH);
                mapImage.src = MAP_IMAGE_PATH;
            } else if (mapImage.complete && mapImageLoaded) {
                // Image already loaded, just render
                if (currentScreen === 'map') {
                    renderMap();
                }
            }
            
            // Add keyboard controls (only once)
            if (!mapKeyHandlerAttached) {
                document.addEventListener('keydown', handleMapKeyPress);
                mapKeyHandlerAttached = true;
            }
            
            // Handle window resize to update canvas size
            if (!window.mapResizeHandler) {
                window.mapResizeHandler = () => {
                    if (currentScreen === 'map' && mapCanvas) {
                        const container = document.getElementById('map-grid-container');
                        if (container) {
                            const rect = container.getBoundingClientRect();
                            mapCanvas.width = rect.width || 800;
                            mapCanvas.height = rect.height || 600;
                            mapCanvas.style.width = mapCanvas.width + 'px';
                            mapCanvas.style.height = mapCanvas.height + 'px';
                            renderMap();
                        }
                    }
                };
                window.addEventListener('resize', window.mapResizeHandler);
            }
        }

        function handleMapKeyPress(event) {
            if (currentScreen !== 'map') return;
            
            const key = event.key.toLowerCase();
            if (key === 'w' || key === 'arrowup') {
                event.preventDefault();
                moveOnMap('up');
            } else if (key === 's' || key === 'arrowdown') {
                event.preventDefault();
                moveOnMap('down');
            } else if (key === 'a' || key === 'arrowleft') {
                event.preventDefault();
                moveOnMap('left');
            } else if (key === 'd' || key === 'arrowright') {
                event.preventDefault();
                moveOnMap('right');
            }
        }

        function renderMap() {
            if (!mapCanvas || !mapCtx) {
                initializeMapRenderer();
                if (!mapCanvas || !mapCtx) return;
            }
            
            const engine = initializeGameEngine();
            if (!engine) return;
            
            const playerPos = engine.gameState.mapPosition || { x: 500, y: 500 };
            
            // Center viewport on player if not manually moved
            if (mapViewportX === 500 && mapViewportY === 500) {
                mapViewportX = playerPos.x;
                mapViewportY = playerPos.y;
            }
            
            // Clear canvas
            mapCtx.fillStyle = '#0a0a0a';
            mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
            
            // Get current zoom level viewport size
            const viewportSize = ZOOM_LEVELS[mapZoomLevel].size;
            
            // Calculate viewport bounds based on zoom level
            let startX, endX, startY, endY;
            let drawX, drawY, drawWidth, drawHeight;
            let gridScaleX, gridScaleY;
            
            if (mapZoomLevel === 'full') {
                // Full map view - show entire map
                startX = 0;
                endX = MAP_GRID_SIZE;
                startY = 0;
                endY = MAP_GRID_SIZE;
                
                // Draw entire map image scaled to fit canvas
                if (mapImageLoaded && mapImage.complete && mapImage.width > 0 && mapImage.height > 0) {
                    const imageAspect = mapImage.width / mapImage.height;
                    const canvasAspect = mapCanvas.width / mapCanvas.height;
                    
                    if (imageAspect > canvasAspect) {
                        drawWidth = mapCanvas.width;
                        drawHeight = mapCanvas.width / imageAspect;
                        drawX = 0;
                        drawY = (mapCanvas.height - drawHeight) / 2;
                    } else {
                        drawWidth = mapCanvas.height * imageAspect;
                        drawHeight = mapCanvas.height;
                        drawX = (mapCanvas.width - drawWidth) / 2;
                        drawY = 0;
                    }
                    
                    mapCtx.drawImage(
                        mapImage,
                        0, 0, mapImage.width, mapImage.height,
                        drawX, drawY, drawWidth, drawHeight
                    );
                    
                    gridScaleX = drawWidth / MAP_GRID_SIZE;
                    gridScaleY = drawHeight / MAP_GRID_SIZE;
                }
            } else {
                // Close or medium view - show area around player
                const halfViewport = Math.floor(viewportSize / 2);
                startX = Math.max(0, mapViewportX - halfViewport);
                endX = Math.min(MAP_GRID_SIZE, mapViewportX + halfViewport);
                startY = Math.max(0, mapViewportY - halfViewport);
                endY = Math.min(MAP_GRID_SIZE, mapViewportY + halfViewport);
                
                // Draw portion of map image based on viewport
                if (mapImageLoaded && mapImage.complete && mapImage.width > 0 && mapImage.height > 0) {
                    const imageScaleX = mapImage.width / MAP_GRID_SIZE;
                    const imageScaleY = mapImage.height / MAP_GRID_SIZE;
                    const sourceX = startX * imageScaleX;
                    const sourceY = startY * imageScaleY;
                    const sourceWidth = (endX - startX) * imageScaleX;
                    const sourceHeight = (endY - startY) * imageScaleY;
                    
                    // Draw to fill entire canvas
                    drawX = 0;
                    drawY = 0;
                    drawWidth = mapCanvas.width;
                    drawHeight = mapCanvas.height;
                    
                    mapCtx.drawImage(
                        mapImage,
                        sourceX, sourceY, sourceWidth, sourceHeight,
                        drawX, drawY, drawWidth, drawHeight
                    );
                    
                    gridScaleX = drawWidth / (endX - startX);
                    gridScaleY = drawHeight / (endY - startY);
                }
            }
            
            // Store scale for rendering markers
            window.mapGridScaleX = gridScaleX || (mapCanvas.width / MAP_GRID_SIZE);
            window.mapGridScaleY = gridScaleY || (mapCanvas.height / MAP_GRID_SIZE);
            window.mapDrawOffsetX = drawX || 0;
            window.mapDrawOffsetY = drawY || 0;
            window.mapViewportStartX = startX;
            window.mapViewportStartY = startY;
            
            // Get biome colors
            const biomeColors = {
                plains: '#90EE90',
                forest: '#228B22',
                desert: '#EDC9AF',
                mountain: '#808080',
                swamp: '#2F4F2F',
                coast: '#4682B4',
                volcanic: '#8B0000',
                tundra: '#E0E0E0',
                jungle: '#2F4F2F',
                canyon: '#CD853F',
                ocean: '#000080',
                river: '#4682B4',
                lake: '#1E90FF',
                unknown: '#333333'
            };
            
            // Render biome overlays if enabled (entire map visible, so skip grid iteration for performance)
            // Grid lines and overlays can be drawn on-demand if needed, but for now just show the image
            
            // Reset alpha
            mapCtx.globalAlpha = 1.0;
            
            // Render towns (only if within viewport)
            const towns = Array.from(engine.townSystem.towns.values());
            towns.forEach(town => {
                // Check if town is within viewport
                if (town.x < startX || town.x >= endX || town.y < startY || town.y >= endY) {
                    return; // Skip towns outside viewport
                }
                
                // Calculate position on canvas
                const gridScaleX = window.mapGridScaleX;
                const gridScaleY = window.mapGridScaleY;
                const drawOffsetX = window.mapDrawOffsetX;
                const drawOffsetY = window.mapDrawOffsetY;
                const viewportStartX = window.mapViewportStartX;
                const viewportStartY = window.mapViewportStartY;
                
                let screenX, screenY;
                if (mapZoomLevel === 'full') {
                    screenX = drawOffsetX + (town.x * gridScaleX);
                    screenY = drawOffsetY + (town.y * gridScaleY);
                } else {
                    screenX = drawOffsetX + ((town.x - viewportStartX) * gridScaleX);
                    screenY = drawOffsetY + ((town.y - viewportStartY) * gridScaleY);
                }
                
                // Draw town marker (larger, more visible)
                const markerSize = Math.max(8, gridScaleX * 2);
                
                // Draw outer glow
                mapCtx.shadowColor = '#FFD700';
                mapCtx.shadowBlur = 10;
                mapCtx.fillStyle = '#FFD700';
                mapCtx.beginPath();
                mapCtx.arc(screenX, screenY, markerSize, 0, Math.PI * 2);
                mapCtx.fill();
                
                // Draw inner circle
                mapCtx.shadowBlur = 0;
                mapCtx.fillStyle = '#8B4513';
                mapCtx.beginPath();
                mapCtx.arc(screenX, screenY, markerSize * 0.6, 0, Math.PI * 2);
                mapCtx.fill();
                
                // Draw town icon (üèòÔ∏è) or label
                mapCtx.fillStyle = '#FFFFFF';
                mapCtx.font = `${markerSize}px Arial`;
                mapCtx.textAlign = 'center';
                mapCtx.textBaseline = 'middle';
                mapCtx.fillText('üèòÔ∏è', screenX, screenY);
            });
            
            // Render ferry points (disabled for now - can be re-enabled later)
            // Ferry system is on the back burner per user request
            /*
            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const square = engine.mapSystem.getSquare(x, y);
                    if (square && square.isFerryPoint && engine.fogOfWar.isExplored(x, y)) {
                        const screenX = (x - startX) * MAP_SQUARE_SIZE * mapZoom;
                        const screenY = (y - startY) * MAP_SQUARE_SIZE * mapZoom;
                        
                        // Draw ferry point marker (anchor icon)
                        mapCtx.fillStyle = '#FFA500';
                        mapCtx.beginPath();
                        mapCtx.arc(screenX + (MAP_SQUARE_SIZE * mapZoom) / 2, screenY + (MAP_SQUARE_SIZE * mapZoom) / 2, 3, 0, Math.PI * 2);
                        mapCtx.fill();
                        mapCtx.strokeStyle = '#FFFFFF';
                        mapCtx.lineWidth = 1;
                        mapCtx.stroke();
                    }
                }
            }
            */
            
            // Render player marker (always centered in viewport for close/medium, positioned for full)
            const gridScaleX = window.mapGridScaleX;
            const gridScaleY = window.mapGridScaleY;
            const drawOffsetX = window.mapDrawOffsetX;
            const drawOffsetY = window.mapDrawOffsetY;
            const viewportStartX = window.mapViewportStartX;
            const viewportStartY = window.mapViewportStartY;
            
            let playerScreenX, playerScreenY;
            if (mapZoomLevel === 'full') {
                playerScreenX = drawOffsetX + (playerPos.x * gridScaleX);
                playerScreenY = drawOffsetY + (playerPos.y * gridScaleY);
            } else {
                // Center player in viewport for close/medium views
                playerScreenX = mapCanvas.width / 2;
                playerScreenY = mapCanvas.height / 2;
            }
            
            // Draw player marker (larger, glowing red circle)
            const playerMarkerSize = Math.max(6, gridScaleX * 1.5);
            
            // Draw outer glow
            mapCtx.shadowColor = '#FF0000';
            mapCtx.shadowBlur = 15;
            mapCtx.fillStyle = '#FF0000';
            mapCtx.beginPath();
            mapCtx.arc(playerScreenX, playerScreenY, playerMarkerSize, 0, Math.PI * 2);
            mapCtx.fill();
            
            // Draw inner circle
            mapCtx.shadowBlur = 0;
            mapCtx.fillStyle = '#FFFFFF';
            mapCtx.beginPath();
            mapCtx.arc(playerScreenX, playerScreenY, playerMarkerSize * 0.7, 0, Math.PI * 2);
            mapCtx.fill();
            
            // Update info display
            updateMapInfo();
        }

        function updateMapInfo() {
            const engine = initializeGameEngine();
            if (!engine) return;
            
            // Check and reset daily travel points
            engine.checkDailyTravelReset();
            
            // Update travel points calculation with current skills from gameData
            if (typeof gameData !== 'undefined' && gameData.skills) {
                const maxPoints = engine.calculateMaxDailyTravelPoints(gameData.skills);
                const roundedMaxPoints = Math.round(maxPoints);
                const currentMax = Math.round(engine.gameState.maxDailyTravelPoints || 10);
                if (currentMax !== roundedMaxPoints) {
                    engine.gameState.maxDailyTravelPoints = roundedMaxPoints;
                    // If max increased, add the difference
                    const difference = roundedMaxPoints - currentMax;
                    if (difference > 0) {
                        engine.gameState.dailyTravelPoints = Math.round(Math.min(
                            (engine.gameState.dailyTravelPoints || 10) + difference,
                            roundedMaxPoints
                        ));
                    }
                }
            }
            
            const playerPos = engine.gameState.mapPosition || { x: 500, y: 500 };
            const square = engine.getCurrentSquare();
            
            // Update travel points display
            const travelPointsEl = document.getElementById('map-travel-points');
            if (travelPointsEl) {
                // Ensure we're reading the most up-to-date values and rounding to integers
                const current = Math.round(engine.gameState.dailyTravelPoints || 10);
                const max = Math.round(engine.gameState.maxDailyTravelPoints || 10);
                travelPointsEl.textContent = `${current} / ${max}`;
                // Color code based on remaining points
                if (current < max * 0.2) {
                    travelPointsEl.style.color = '#e53e3e'; // Red
                } else if (current < max * 0.5) {
                    travelPointsEl.style.color = '#dd6b20'; // Orange
                } else {
                    travelPointsEl.style.color = '#38a169'; // Green
                }
            }
            
            // Update position display
            const posEl = document.getElementById('map-player-position');
            if (posEl) {
                posEl.textContent = `X: ${playerPos.x}, Y: ${playerPos.y}`;
            }
            
            // Update biome display
            const biomeEl = document.getElementById('map-current-biome');
            if (biomeEl && square) {
                const biomeName = (window.GameData && window.GameData.map && window.GameData.map.biomes && window.GameData.map.biomes[square.biome]?.name) || square.biome || 'Unknown';
                biomeEl.textContent = biomeName;
            }
            
            // Update zone display
            const zoneEl = document.getElementById('map-current-zone');
            if (zoneEl && square) {
                zoneEl.textContent = square.zone || 'Unknown';
            }
            
            // Update level requirement
            const levelReqEl = document.getElementById('map-level-req');
            if (levelReqEl && square) {
                levelReqEl.textContent = square.levelRequirement || 1;
            }
            
            // Update exploration percentage
            // Exploration percentage removed - fog of war disabled
            
            // Update biome square panel
            updateBiomeSquarePanel();
        }

        function updateBiomeSquarePanel() {
            const engine = initializeGameEngine();
            if (!engine) return;
            
            const panel = document.getElementById('biome-square-panel');
            if (!panel) return;
            
            const square = engine.getCurrentSquare();
            if (!square) {
                panel.style.display = 'none';
                return;
            }
            
            // Hide panel if in a town
            if (square.isTown) {
                panel.style.display = 'none';
                return;
            }
            
            // Show panel
            panel.style.display = 'block';
            
            // Get biome data
            const biomeData = window.GameData && window.GameData.map && window.GameData.map.biomes && window.GameData.map.biomes[square.biome];
            const biomeName = biomeData ? biomeData.name : square.biome || 'Unknown';
            
            // Update biome description
            const descEl = document.getElementById('biome-description');
            if (descEl) {
                const descriptions = {
                    plains: "Rolling grasslands stretch as far as the eye can see. A peaceful landscape where travelers can rest easy.",
                    forest: "Ancient trees tower overhead, their canopies filtering the sunlight. The forest teems with life and mystery.",
                    desert: "Endless dunes shift with the wind. The harsh sun beats down on this unforgiving landscape.",
                    mountain: "Towering peaks pierce the sky. The thin air and treacherous paths make this a challenging terrain.",
                    swamp: "Murky waters and twisted trees create an eerie atmosphere. Danger lurks in the shadows.",
                    coast: "Where land meets sea, the salty air carries the promise of adventure and hidden treasures.",
                    volcanic: "Molten rock flows and the ground trembles. Only the brave dare venture into these fiery wastes.",
                    tundra: "A frozen wasteland where the cold bites deep. Survival here requires great strength and preparation.",
                    jungle: "Dense vegetation and exotic sounds fill the air. The jungle hides many secrets and dangers.",
                    canyon: "Deep ravines cut through the earth, creating a maze of stone. The echoes of ancient times linger here."
                };
                descEl.textContent = descriptions[square.biome] || "An unknown region of Pandimus.";
            }
            
            // Update biome stats
            const playerPos = engine.gameState.mapPosition || { x: 500, y: 500 };
            const distanceFromStart = engine.mapSystem.getDistance(playerPos.x, playerPos.y, 500, 500);
            
            const zoneDiffEl = document.getElementById('biome-zone-difficulty');
            if (zoneDiffEl) {
                zoneDiffEl.textContent = square.zone || 'Unknown';
            }
            
            const levelReqEl = document.getElementById('biome-level-req');
            if (levelReqEl) {
                levelReqEl.textContent = square.levelRequirement || 1;
            }
            
            const distanceEl = document.getElementById('biome-distance-start');
            if (distanceEl) {
                distanceEl.textContent = Math.floor(distanceFromStart) + ' units';
            }
            
            // Find nearest town
            const nearestTownEl = document.getElementById('biome-nearest-town');
            if (nearestTownEl) {
                let nearestTown = null;
                let nearestDistance = Infinity;
                
                engine.townSystem.towns.forEach(town => {
                    const dist = engine.mapSystem.getDistance(playerPos.x, playerPos.y, town.x, town.y);
                    if (dist < nearestDistance) {
                        nearestDistance = dist;
                        nearestTown = town;
                    }
                });
                
                if (nearestTown) {
                    nearestTownEl.textContent = `${nearestTown.name} (${Math.floor(nearestDistance)} units)`;
                } else {
                    nearestTownEl.textContent = 'None';
                }
            }
            
            // Update enemies list
            const enemiesListEl = document.getElementById('biome-enemies-list');
            const enemyCountEl = document.getElementById('biome-enemy-count');
            if (enemiesListEl && enemyCountEl) {
                const entities = engine.getCurrentEntities();
                const enemies = entities.enemies || [];
                enemyCountEl.textContent = enemies.length;
                
                if (enemies.length === 0) {
                    enemiesListEl.innerHTML = '<div class="biome-empty-message">No enemies present</div>';
                } else {
                    enemiesListEl.innerHTML = enemies.map(enemy => {
                        return `
                            <div class="biome-entity-item">
                                <div class="biome-entity-info">
                                    <div class="biome-entity-name">${enemy.name}</div>
                                    <div style="font-size: 0.75rem; color: #666;">
                                        Level ${enemy.level} | HP: ${enemy.hp.toFixed(0)}/${enemy.maxHp}
                                    </div>
                                </div>
                                <div class="biome-entity-actions">
                                    <button onclick="inspectEnemy('${enemy.id}')" title="Inspect">üëÅÔ∏è</button>
                                    <button onclick="fightEnemy('${enemy.id}')" title="Fight">‚öîÔ∏è</button>
                                </div>
                            </div>
                        `;
                    }).join('');
                }
            }
            
            // Update resources list
            const resourcesListEl = document.getElementById('biome-resources-list');
            const resourceCountEl = document.getElementById('biome-resource-count');
            if (resourcesListEl && resourceCountEl) {
                const entities = engine.getCurrentEntities();
                const resources = entities.items ? entities.items.filter(item => item.resourceId || (item.type && ['ore', 'wood', 'plant', 'crystal', 'stone'].includes(item.type))) : [];
                resourceCountEl.textContent = resources.length;
                
                if (resources.length === 0) {
                    resourcesListEl.innerHTML = '<div class="biome-empty-message">No resources available</div>';
                } else {
                    // Group resources by type
                    const resourceGroups = {};
                    resources.forEach(resource => {
                        const key = resource.resourceId || resource.name;
                        if (!resourceGroups[key]) {
                            resourceGroups[key] = {
                                resource: resource,
                                count: 0,
                                ids: []
                            };
                        }
                        resourceGroups[key].count++;
                        resourceGroups[key].ids.push(resource.id);
                    });
                    
                    resourcesListEl.innerHTML = Object.values(resourceGroups).map(group => {
                        const res = group.resource;
                        const resourceKey = res.resourceId || res.name.toLowerCase().replace(/\s+/g, '_');
                        return `
                            <div class="biome-entity-item">
                                <div class="biome-entity-info">
                                    <div class="biome-entity-name">${res.name}</div>
                                    <div style="font-size: 0.75rem; color: #666;">
                                        ${res.type || 'resource'} | Available: ${group.count}
                                    </div>
                                </div>
                                <div class="biome-entity-actions">
                                    <button onclick="gatherResource('${resourceKey}', ${group.count})" title="Gather">‚õèÔ∏è</button>
                                </div>
                            </div>
                        `;
                    }).join('');
                }
            }
        }

        function inspectEnemy(enemyId) {
            const engine = initializeGameEngine();
            if (!engine) return;
            
            const entities = engine.getCurrentEntities();
            const enemy = entities.enemies.find(e => e.id === enemyId);
            
            if (!enemy) {
                showTemporaryMessage('Enemy not found!', 'error');
                return;
            }
            
            const stats = `
Enemy: ${enemy.name}
Level: ${enemy.level}
HP: ${enemy.hp.toFixed(0)} / ${enemy.maxHp}
Attack Power: ${enemy.ap}
Armor: ${enemy.armor}
Gold Reward: ${enemy.gold[0]}-${enemy.gold[1]}
Experience: ${enemy.exp}
            `.trim();
            
            // Show in a modal-style message
            showTemporaryMessage(stats.replace(/\n/g, ' | '), 'info');
        }

        function fightEnemy(enemyId) {
            const engine = initializeGameEngine();
            if (!engine || !engine.gameState.player) {
                alert('Please create a character first!');
                return;
            }
            
            const pos = engine.gameState.mapPosition;
            const result = engine.startCombatWithEnemy(pos.x, pos.y, enemyId);
            
            if (!result.success) {
                alert(result.message || 'Failed to start combat!');
                return;
            }
            
            // Start combat with this enemy
            startCombatWithMapEnemy(result.enemy, result.player);
        }

        function startCombatWithMapEnemy(enemy, player) {
            if (!player) {
                player = gameData.player || player;
            }
            
            if (!player) {
                alert('Player data not found!');
                return;
            }
            
            // Initialize combat state
            combatState = {
                player: {
                    name: player.name,
                    hp: player.hp,
                    maxHp: player.maxHp,
                    power: player.ap || player.attributes?.Power || 20,
                    defending: false
                },
                enemy: {
                    name: enemy.name,
                    hp: enemy.hp,
                    maxHp: enemy.maxHp,
                    power: enemy.ap,
                    defending: false,
                    id: enemy.id,
                    enemyId: enemy.enemyId
                },
                turn: 'player',
                turnCount: 0,
                log: [],
                isMapCombat: true // Flag to indicate this is a map encounter
            };
            
            // Show combat screen
            showScreen('combat');
            
            // Initialize combat log for this combat instance
            initializeCombatLog();
            
            // Update combat display
            updateCombatDisplay();
            addCombatLog(`Combat started! You encounter ${enemy.name}!`);
            
            // Start automatic combat after a short delay
            setTimeout(() => {
                if (combatState && combatState.turn === 'player') {
                    automaticPlayerTurn();
                }
            }, 1000);
        }

        // Resource gathering modal state
        let currentGatheringResource = null;
        let currentGatheringMax = 1;

        function gatherResource(resourceId, maxQuantity) {
            const engine = initializeGameEngine();
            if (!engine) return;
            
            // Get resource name for display
            const entities = engine.getCurrentEntities();
            const resource = entities.items.find(item => 
                (item.id === resourceId || item.resourceId === resourceId) &&
                item.type && ['ore', 'wood', 'plant', 'crystal', 'stone'].includes(item.type)
            );
            
            const resourceName = resource ? resource.name : 'Resource';
            
            // Store current gathering state
            currentGatheringResource = resourceId;
            currentGatheringMax = maxQuantity;
            
            // Show modal
            document.getElementById('resource-gathering-name').textContent = resourceName;
            document.getElementById('resource-gathering-max').textContent = maxQuantity;
            const quantityInput = document.getElementById('resource-quantity-input');
            quantityInput.value = '1';
            quantityInput.max = maxQuantity;
            quantityInput.min = 1;
            
            document.getElementById('resource-gathering-modal').style.display = 'flex';
            quantityInput.focus();
            quantityInput.select();
        }

        function closeResourceGatheringModal() {
            document.getElementById('resource-gathering-modal').style.display = 'none';
            currentGatheringResource = null;
            currentGatheringMax = 1;
        }

        function setResourceQuantity(quantity) {
            const input = document.getElementById('resource-quantity-input');
            const max = parseInt(input.max);
            const newValue = Math.min(quantity, max);
            input.value = newValue;
        }

        function setResourceQuantityMax() {
            const input = document.getElementById('resource-quantity-input');
            input.value = input.max;
        }

        function confirmGatherResource() {
            if (!currentGatheringResource) {
                closeResourceGatheringModal();
                return;
            }
            
            const engine = initializeGameEngine();
            if (!engine) return;
            
            const quantityInput = document.getElementById('resource-quantity-input');
            const qty = parseInt(quantityInput.value);
            
            if (isNaN(qty) || qty < 1 || qty > currentGatheringMax) {
                alert(`Invalid quantity! Please enter a number between 1 and ${currentGatheringMax}.`);
                return;
            }
            
            // Call gather method
            const result = engine.gatherResource(engine.gameState.mapPosition.x, engine.gameState.mapPosition.y, currentGatheringResource, qty);
            
            closeResourceGatheringModal();
            
            if (result.success) {
                // Show success message in a non-blocking way
                const message = `Gathered ${qty} ${result.resourceName}!`;
                showTemporaryMessage(message);
                updateBiomeSquarePanel();
                saveGameState();
            } else {
                showTemporaryMessage(result.message || 'Failed to gather resource!', 'error');
            }
        }

        function showTemporaryMessage(message, type = 'success') {
            // Create or update temporary message element
            let msgEl = document.getElementById('temp-message');
            if (!msgEl) {
                msgEl = document.createElement('div');
                msgEl.id = 'temp-message';
                msgEl.style.cssText = 'position: fixed; top: 20px; right: 20px; padding: 1rem 1.5rem; border-radius: 8px; z-index: 10001; font-weight: bold; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: opacity 0.3s; max-width: 400px; word-wrap: break-word;';
                document.body.appendChild(msgEl);
            }
            
            msgEl.textContent = message;
            
            // Set color based on type
            if (type === 'error') {
                msgEl.style.background = '#e53e3e';
            } else if (type === 'info') {
                msgEl.style.background = '#3182ce';
            } else {
                msgEl.style.background = '#38a169';
            }
            
            msgEl.style.color = '#ffffff';
            msgEl.style.opacity = '1';
            msgEl.style.display = 'block';
            
            // Hide after appropriate time (longer for info messages)
            const hideDelay = type === 'info' ? 5000 : 3000;
            setTimeout(() => {
                msgEl.style.opacity = '0';
                setTimeout(() => {
                    msgEl.style.display = 'none';
                }, 300);
            }, hideDelay);
        }

        // Close modal on escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const modal = document.getElementById('resource-gathering-modal');
                if (modal && modal.style.display === 'flex') {
                    closeResourceGatheringModal();
                }
            }
        });

        function handleMapCombatVictory() {
            const engine = initializeGameEngine();
            if (!engine) return;
            
            const result = engine.handleCombatVictory();
            
            if (result.success) {
                addCombatLog(`Victory! Gained ${result.gold} gold and ${result.exp} experience!`);
                
                // Update player stats
                if (player) {
                    player.experience = (player.experience || 0) + result.exp;
                    player.hp = Math.min(player.maxHp, player.hp); // Keep current HP
                }
                
                // Update currency
                if (gameData.currency) {
                    gameData.currency.gold = (gameData.currency.gold || 0) + result.gold;
                }
                
                updateCurrencyDisplay();
                saveGameState();
            }
            
            // Return to map after a delay
            setTimeout(() => {
                combatState = null;
                showMap();
                updateBiomeSquarePanel();
            }, 2000);
        }

        function handleMapCombatDefeat() {
            const engine = initializeGameEngine();
            if (!engine) return;
            
            const result = engine.handleCombatDefeat();
            
            if (result.success) {
                addCombatLog("You have been defeated! Returning to last town...");
                
                // Update player HP
                if (player) {
                    player.hp = Math.round((player.maxHp * 0.5) * 10) / 10; // 50% HP
                }
                
                updateCurrencyDisplay();
                saveGameState();
            }
            
            // Return to map after a delay
            setTimeout(() => {
                combatState = null;
                showMap();
                updateBiomeSquarePanel();
            }, 2000);
        }

        function moveOnMap(direction) {
            const engine = initializeGameEngine();
            if (!engine || !engine.gameState.player) {
                alert('Please create a character first!');
                return;
            }
            
            const result = engine.movePlayer(direction);
            
            if (result.success) {
                // Update viewport to follow player
                mapViewportX = result.position.x;
                mapViewportY = result.position.y;
                
                // Check respawns for new square
                checkSquareRespawns();
                
                // Re-render map
                renderMap();
                
                // Update map info (including travel points)
                updateMapInfo();
                
                // Save game state
                saveGameState();
                
                // Show message if entered a town
                if (result.isTown && result.town) {
                    console.log(`Entered town: ${result.town.name}`);
                }
            } else {
                // Show error message
                if (result.message) {
                    alert(result.message);
                }
                // Still update map info to refresh travel points display
                updateMapInfo();
            }
        }

        function centerMapOnPlayer() {
            const engine = initializeGameEngine();
            if (!engine) return;
            
            const playerPos = engine.gameState.mapPosition || { x: 500, y: 500 };
            mapViewportX = playerPos.x;
            mapViewportY = playerPos.y;
            
            // For full map view, center doesn't change viewport, but update anyway
            if (mapZoomLevel !== 'full') {
                renderMap();
            } else {
                // For full map, just re-render to update player position
                renderMap();
            }
        }

        function setMapZoomLevel(level) {
            if (ZOOM_LEVELS[level]) {
                mapZoomLevel = level;
                // Center viewport on player when changing zoom
                const engine = initializeGameEngine();
                if (engine) {
                    const playerPos = engine.gameState.mapPosition || { x: 500, y: 500 };
                    mapViewportX = playerPos.x;
                    mapViewportY = playerPos.y;
                }
                initializeMapRenderer();
                renderMap();
                updateZoomLevelButtons();
            }
        }
        
        function zoomMapIn() {
            // Cycle through zoom levels: full -> medium -> close
            if (mapZoomLevel === 'full') {
                setMapZoomLevel('medium');
            } else if (mapZoomLevel === 'medium') {
                setMapZoomLevel('close');
            }
        }

        function zoomMapOut() {
            // Cycle through zoom levels: close -> medium -> full
            if (mapZoomLevel === 'close') {
                setMapZoomLevel('medium');
            } else if (mapZoomLevel === 'medium') {
                setMapZoomLevel('full');
            }
        }
        
        function updateZoomLevelButtons() {
            // Update button states to show current zoom level
            const buttons = document.querySelectorAll('[data-zoom-level]');
            buttons.forEach(btn => {
                if (btn.dataset.zoomLevel === mapZoomLevel) {
                    btn.style.background = '#8b4513';
                    btn.style.color = '#fff';
                } else {
                    btn.style.background = '';
                    btn.style.color = '';
                }
            });
        }

        function toggleBiomeOverlays() {
            showBiomeOverlays = !showBiomeOverlays;
            const toggleBtn = document.getElementById('biome-overlay-toggle');
            if (toggleBtn) {
                toggleBtn.style.background = showBiomeOverlays ? '#8b4513' : '';
                toggleBtn.style.color = showBiomeOverlays ? '#fff' : '';
            }
            renderMap(); // Re-render with new overlay setting
        }

        function saveGameState() {
            const engine = initializeGameEngine();
            if (!engine) return;
            
            // Update gameData with map state
            if (!gameData.mapPosition) {
                gameData.mapPosition = { x: 500, y: 500 };
            }
            gameData.mapPosition = engine.gameState.mapPosition;
            
            // Fog of war removed - no need to save explored squares
            
            // Save discovered towns
            gameData.discoveredTowns = engine.gameState.discoveredTowns || ['starting_town'];
            
            // Save travel points state
            gameData.dailyTravelPoints = engine.gameState.dailyTravelPoints;
            gameData.maxDailyTravelPoints = engine.gameState.maxDailyTravelPoints;
            gameData.lastTravelReset = engine.gameState.lastTravelReset;
            
            // Save to localStorage
            saveGameData();
        }

        function showMap() {
            showScreen('map');
            
            // Initialize game engine and map renderer
            const engine = initializeGameEngine();
            if (!engine) {
                console.warn('GameEngine not available - map features may be limited');
                return;
            }
            
            // Initialize map renderer (will resize canvas to container)
            setTimeout(() => {
                initializeMapRenderer();
                // Re-render after a short delay to ensure container is sized
                setTimeout(() => {
                    renderMap();
                }, 100);
            }, 50);
            
            // Show loading indicator if map needs to be generated
            if (!engine.mapGenerated) {
                showMapLoadingIndicator();
                engine.generateMap((progress) => {
                    console.log('Map generation progress:', progress);
                    updateMapLoadingIndicator(progress);
                }).then(() => {
                    console.log('Map generation completed successfully');
                    hideMapLoadingIndicator();
                    // Center viewport on player
                    const playerPos = engine.gameState.mapPosition || { x: 500, y: 500 };
                    mapViewportX = playerPos.x;
                    mapViewportY = playerPos.y;
                    
                    // Check respawns for current square
                    checkSquareRespawns();
                    
                    // Render the map
                    renderMap();
                }).catch(err => {
                    console.error('Map generation failed:', err);
                    console.error('Error stack:', err.stack);
                    hideMapLoadingIndicator();
                    alert('Failed to generate map: ' + (err.message || 'Unknown error') + '. Please check console for details.');
                });
            } else {
                // Map already generated, just render it
                const playerPos = engine.gameState.mapPosition || { x: 500, y: 500 };
                mapViewportX = playerPos.x;
                mapViewportY = playerPos.y;
                
                // Check respawns for current square
                checkSquareRespawns();
                
                // Render the map
                setTimeout(() => {
                    renderMap();
                }, 100);
            }
        }
        
        function showMapLoadingIndicator() {
            let loadingDiv = document.getElementById('map-loading-indicator');
            if (!loadingDiv) {
                loadingDiv = document.createElement('div');
                loadingDiv.id = 'map-loading-indicator';
                loadingDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); color: white; padding: 20px; border-radius: 8px; z-index: 10000; text-align: center;';
                loadingDiv.innerHTML = '<div style="margin-bottom: 10px;">Generating Map...</div><div id="map-loading-progress" style="font-size: 14px; color: #90EE90;">Starting...</div>';
                document.body.appendChild(loadingDiv);
            }
            loadingDiv.style.display = 'block';
        }
        
        function updateMapLoadingIndicator(progress) {
            const progressDiv = document.getElementById('map-loading-progress');
            if (progressDiv) {
                progressDiv.textContent = progress;
            }
        }
        
        function hideMapLoadingIndicator() {
            const loadingDiv = document.getElementById('map-loading-indicator');
            if (loadingDiv) {
                loadingDiv.style.display = 'none';
            }
        }

        function checkSquareRespawns() {
            const engine = initializeGameEngine();
            if (!engine || !engine.mapGenerator) return;
            
            const square = engine.getCurrentSquare();
            if (!square) return;
            
            const pos = engine.gameState.mapPosition;
            const startingTown = window.GameData && window.GameData.map && window.GameData.map.startingTown;
            const startingTownX = startingTown ? startingTown.x : 500;
            const startingTownY = startingTown ? startingTown.y : 500;
            const towns = Array.from(engine.townSystem.towns.values());
            
            // Check and respawn enemies/resources
            engine.mapGenerator.checkRespawn(
                engine.mapSystem,
                pos.x,
                pos.y,
                square,
                startingTownX,
                startingTownY,
                towns
            );
        }
        
        // Handle window resize for map canvas
        window.addEventListener('resize', () => {
            if (currentScreen === 'map' && mapCanvas) {
                initializeMapRenderer();
                renderMap();
            }
        });

        function showInventory() {
            showScreen('inventory');
            updateInventoryDisplay();
            updateCraftingDisplay();
            updateMaterialsDisplay();
            
            // Check if player is in a town and show/hide refinement tab
            const engine = initializeGameEngine();
            const refinementTabBtn = document.getElementById('refinement-tab-btn');
            if (refinementTabBtn && engine) {
                const square = engine.getCurrentSquare();
                const isInTown = square && square.isTown;
                refinementTabBtn.style.display = isInTown ? 'inline-block' : 'none';
            }
        }

        function showInventoryTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.style.display = 'none';
            });
            
            // Remove active class from all tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab content
            const tabElement = document.getElementById(tabName + '-tab');
            if (tabElement) {
                tabElement.style.display = 'block';
            }
            
            // Add active class to clicked button
            if (event && event.target) {
                event.target.classList.add('active');
            }
            
            // Update displays based on tab
            if (tabName === 'items') {
                updateInventoryDisplay();
            } else if (tabName === 'crafting') {
                updateCraftingDisplay();
            } else if (tabName === 'materials') {
                updateMaterialsDisplay();
            } else if (tabName === 'refinement') {
                updateRefinementDisplay();
            }
        }

        function updateCraftingDisplay() {
            const recipesContainer = document.getElementById('crafting-recipes');
            if (!recipesContainer) return;
            
            recipesContainer.innerHTML = '';
            
            Object.entries(craftingRecipes).forEach(([recipeId, recipe]) => {
                const recipeCard = document.createElement('div');
                recipeCard.className = 'recipe-card';
                
                const canCraftItem = canCraft(recipeId);
                const materialsHtml = Object.entries(recipe.materials)
                    .map(([material, amount]) => {
                        const hasEnough = gameData.crafting.materials[material] >= amount;
                        return `<span style="color: ${hasEnough ? '#4a8b3d' : '#c41e3a'}">${material}: ${amount}</span>`;
                    })
                    .join(' ');
                
                recipeCard.innerHTML = `
                    <h4>${recipe.name}</h4>
                    <div class="recipe-materials">${materialsHtml}</div>
                    <div class="recipe-cost">Cost: ${recipe.goldCost} gold</div>
                    <button class="btn ${canCraftItem ? 'btn-primary' : 'btn-secondary'}" 
                            onclick="craftItem('${recipeId}')" 
                            ${!canCraftItem ? 'disabled' : ''}>
                        ${canCraftItem ? 'Craft' : 'Cannot Craft'}
                    </button>
                `;
                
                recipesContainer.appendChild(recipeCard);
            });
        }

        function updateMaterialsDisplay() {
            const materialsContainer = document.getElementById('materials-display');
            if (!materialsContainer) return;
            
            materialsContainer.innerHTML = '';
            
            Object.entries(gameData.crafting.materials).forEach(([material, count]) => {
                if (count > 0) { // Only show materials we have
                    const materialItem = document.createElement('div');
                    materialItem.className = 'material-item';
                    materialItem.innerHTML = `
                        <h4>${material.charAt(0).toUpperCase() + material.slice(1)}</h4>
                        <div class="material-count">${count}</div>
                    `;
                    materialsContainer.appendChild(materialItem);
                }
            });
            
            if (materialsContainer.innerHTML === '') {
                materialsContainer.innerHTML = '<p>No materials collected yet. Fight enemies to gather materials!</p>';
            }
        }

        function updateRefinementDisplay() {
            const recipesContainer = document.getElementById('refinement-recipes');
            if (!recipesContainer) return;
            
            const engine = initializeGameEngine();
            if (!engine) return;
            
            // Check if player is in a town
            const square = engine.getCurrentSquare();
            const isInTown = square && square.isTown;
            
            if (!isInTown) {
                recipesContainer.innerHTML = '<p style="color: #c41e3a;">You must be in a town to refine resources.</p>';
                return;
            }
            
            recipesContainer.innerHTML = '';
            
            // Get raw resources from inventory
            const rawResources = {};
            if (engine.gameState.inventory) {
                engine.gameState.inventory.forEach(item => {
                    if (item.type === 'resource' && item.resourceId) {
                        const key = item.resourceId;
                        if (!rawResources[key]) {
                            rawResources[key] = {
                                resource: item,
                                count: 0
                            };
                        }
                        rawResources[key].count++;
                    }
                });
            }
            
            // Display available refinement recipes
            if (window.GameData && window.GameData.refinementRecipes) {
                Object.entries(window.GameData.refinementRecipes).forEach(([recipeId, recipe]) => {
                    const rawResource = rawResources[recipe.raw];
                    const hasResource = rawResource && rawResource.count > 0;
                    
                    const recipeCard = document.createElement('div');
                    recipeCard.className = 'recipe-card';
                    recipeCard.style.marginBottom = '1rem';
                    
                    recipeCard.innerHTML = `
                        <h4>${recipe.name}</h4>
                        <div class="recipe-materials">
                            <span style="color: ${hasResource ? '#4a8b3d' : '#c41e3a'}">
                                ${recipe.raw}: ${hasResource ? rawResource.count : 0} available
                            </span>
                        </div>
                        <div style="margin-top: 0.5rem;">
                            <input type="number" id="refine-qty-${recipeId}" min="1" max="${hasResource ? rawResource.count : 0}" value="1" style="width: 80px; padding: 0.25rem; margin-right: 0.5rem;">
                            <button class="btn ${hasResource ? 'btn-primary' : 'btn-secondary'}" 
                                    onclick="refineResource('${square.townId}', '${recipe.raw}', '${recipeId}')" 
                                    ${!hasResource ? 'disabled' : ''}>
                                Refine
                            </button>
                        </div>
                    `;
                    
                    recipesContainer.appendChild(recipeCard);
                });
            }
            
            if (recipesContainer.innerHTML === '') {
                recipesContainer.innerHTML = '<p>No refinement recipes available.</p>';
            }
        }

        function refineResource(townId, rawResourceId, recipeId) {
            const engine = initializeGameEngine();
            if (!engine) return;
            
            const qtyInput = document.getElementById(`refine-qty-${recipeId}`);
            if (!qtyInput) return;
            
            const quantity = parseInt(qtyInput.value);
            if (isNaN(quantity) || quantity < 1) {
                alert('Invalid quantity!');
                return;
            }
            
            const result = engine.refineResource(townId, rawResourceId, quantity);
            
            if (result.success) {
                alert(`Refined ${result.quantity} ${rawResourceId} into ${result.refinedName}!`);
                updateRefinementDisplay();
                updateInventoryDisplay();
                saveGameState();
            } else {
                alert(result.message || 'Failed to refine resource!');
            }
        }

        function showShops() {
            showScreen('shops');
            updateShopsDisplay();
        }

        function showEncounters() {
            if (!currentLocation) {
                alert("Please select a location from the map first!");
                showMap();
                return;
            }
            showScreen('combat'); // Encounters shows the combat screen
            
            // Idle combat disabled - always show normal combat controls
            // Ensure idle combat is stopped if it was somehow active
            if (gameData.idleCombat.isActive) {
                gameData.idleCombat.isActive = false;
                gameData.idleCombat.location = null;
                gameData.idleCombat.startTime = null;
            }
            
            document.getElementById('idle-combat-info').style.display = 'none';
            document.getElementById('normal-combat-controls').style.display = 'block';
            startNewCombat(); // Start normal combat
        }

        // Character persistence
        function saveGameData() {
            try {
                // Update last save time for offline progression
                gameData.idleCombat.lastSaveTime = Date.now();
                localStorage.setItem('pandimusGameData', JSON.stringify(gameData));
                console.log("Game data saved to localStorage");
            } catch (error) {
                console.error("Error saving game data:", error);
            }
        }

        function loadGameData() {
            try {
                const savedData = localStorage.getItem('pandimusGameData');
                if (savedData) {
                    const parsedData = JSON.parse(savedData);
                    
                    // Merge saved data with current gameData structure
                    gameData = {
                        ...gameData,
                        ...parsedData,
                        // Ensure all required properties exist
                        inventory: parsedData.inventory || [],
                        equipment: {
                            ...gameData.equipment,
                            ...parsedData.equipment
                        },
                        skills: {
                            ...gameData.skills,
                            ...parsedData.skills
                        },
                        attributeToggles: parsedData.attributeToggles || { Power: 'lock', Dexterity: 'lock', Vitality: 'lock' },
                        skillToggles: {
                            ...gameData.skillToggles,
                            ...parsedData.skillToggles
                        },
                        currency: parsedData.currency || { gold: 100 },
                        vendors: parsedData.vendors || gameData.vendors,
                        locations: gameData.locations, // Always use the current locations structure
                        player: parsedData.player ? {
                            ...parsedData.player,
                            // Remove level property if it exists
                            level: undefined
                        } : parsedData.player
                    };
                    
                    player = gameData.player;
                    
                    // Enforce skill caps on load (fix any existing saves that exceed caps)
                    enforceSkillCaps();
                    
                    // Recalculate health with current equipment and skills
                    recalculateHealth();
                    
                    console.log("Game data loaded from localStorage:", player);
                    return true;
                }
            } catch (error) {
                console.error("Error loading game data:", error);
            }
            return false;
        }

        // Toggle functions
        // Primary Skills (formerly Attributes) now use the same toggle system as Secondary Skills
        // Power, Dexterity, and Vitality are now treated as skills for consistency
        function toggleAttribute(attributeName, state) {
            // Redirect to toggleSkill for consistency - Primary Skills use the same system
            toggleSkill(attributeName, state);
        }

        function toggleSkill(skillName, state) {
            if (!player) {
                alert("Please create a character first!");
                return;
            }
            
            // Check if this is a Primary Skill (Power, Dexterity, Vitality)
            const isPrimarySkill = ['Power', 'Dexterity', 'Vitality'].includes(skillName);
            
            if (isPrimarySkill) {
                // Primary Skills use attributeToggles - just set the toggle state
                // The actual training happens during combat, not here
                gameData.attributeToggles[skillName] = state;
            } else {
                // Secondary Skills use skillToggles - just set the toggle state
                // The actual training happens during combat, not here
                gameData.skillToggles[skillName] = state;
            }
            
            // Update button states to show which toggle is active
            updateToggleButtonState(skillName, state);
            saveGameData();
            
            console.log(`${skillName} toggle set to: ${state} (will train during combat)`);
        }

        function updateToggleButtons() {
            // Update Primary Skill toggles (Power, Dexterity, Vitality)
            // They now use data-skill attribute for consistency
            Object.keys(gameData.attributeToggles).forEach(attr => {
                const currentState = gameData.attributeToggles[attr];
                updateToggleButtonState(attr, currentState);
            });
            
            // Update Secondary Skill toggles
            Object.keys(gameData.skillToggles).forEach(skill => {
                const currentState = gameData.skillToggles[skill];
                updateToggleButtonState(skill, currentState);
            });
        }

        // Character management
        function createNewCharacter() {
            console.log("=== CREATE CHARACTER FUNCTION CALLED ===");
            
            // Get the name input - try multiple ways to ensure we get it
            let nameInput = document.getElementById('char-name-input');
            
            // If not found, try querySelector
            if (!nameInput) {
                nameInput = document.querySelector('#char-name-input');
            }
            
            // If still not found, try by class
            if (!nameInput) {
                nameInput = document.querySelector('.character-name-input');
            }
            
            console.log("Name input element:", nameInput);
            console.log("Input value:", nameInput ? nameInput.value : 'N/A');
            console.log("Input disabled:", nameInput ? nameInput.disabled : 'N/A');
            console.log("Input readonly:", nameInput ? nameInput.readOnly : 'N/A');
            
            if (!nameInput) {
                alert("Error: Name input field not found! Please refresh the page.");
                return;
            }
            
            // Ensure input is enabled and can receive input
            nameInput.disabled = false;
            nameInput.readOnly = false;
            nameInput.removeAttribute('disabled');
            nameInput.removeAttribute('readonly');
            
            // Focus the input to ensure it's active
            nameInput.focus();
            
            // Add a small delay to ensure focus is set, then get the value
            setTimeout(() => {
                // Get the value
                const name = nameInput.value ? nameInput.value.trim() : '';
                console.log("Name entered (trimmed):", name);
                console.log("Name length:", name.length);
                
                if (!name || name.length === 0) {
                    alert("Please enter a character name in the text field above!");
                    nameInput.focus();
                    nameInput.select();
                    return;
                }
                
                // Continue with character creation...
                createCharacterWithName(name);
            }, 50);
        }
        
        function createCharacterWithName(name) {
            
        // Create the character
        player = {
            name: name,
            hp: 100,
            maxHp: 100,
            attributes: {
                Power: 0.0,
                Dexterity: 0.0,
                Vitality: 0.0
            },
            experience: 0
        };
        
        // Calculate initial HP with Endurance bonus and equipment
        // Use recalculateHealth() to ensure equipment bonuses are included
        recalculateHealth();
            
            // Initialize currency if not exists
            if (!gameData.currency) {
                gameData.currency = { gold: 100 };
            }
            
            gameData.player = player;
            
            // Create character in GameEngine
            const engine = initializeGameEngine();
            if (engine) {
                // Convert attributes to GameEngine format (STR, DEX, CON, INT, LCK)
                const engineAttrs = {
                    STR: player.attributes.Power || 0,
                    DEX: player.attributes.Dexterity || 0,
                    CON: player.attributes.Vitality || 0,
                    INT: 10,
                    LCK: 10
                };
                
                // Create character in engine (this will also generate map if needed)
                engine.createCharacter(name, 'warrior');
                
                // Sync player data
                if (engine.gameState.player) {
                    engine.gameState.player.attributes = engineAttrs;
                    engine.calculateDerivedStats();
                }
                
                // Save map state
                saveGameState();
            }
            
            // Give starting items from the new system
            const startingItems = sampleItems.filter(item => item.zones.includes("vendor")).slice(0, 4);
            gameData.inventory = [...startingItems];
            
            // Equip starting items
            gameData.equipment.mainhand = startingItems.find(item => item.slot === "mainhand") || null;
            gameData.equipment.helmet = startingItems.find(item => item.slot === "helmet") || null;
            gameData.equipment.chest = startingItems.find(item => item.slot === "chest") || null;
            
            console.log("Character created:", player);
            console.log("Game data:", gameData);
            
            // Save to localStorage and update display
            saveGameData();
            updateCharacterDisplay();
            updateToggleButtons();
            updateCurrencyDisplay();
            
            alert(`Welcome, ${name}! Character created successfully!`);
        }

        function updateCharacterName() {
            const newName = document.getElementById('char-name-edit').value.trim();
            if (newName && player) {
                player.name = newName;
                updateCharacterDisplay();
                alert(`Character name updated to ${newName}!`);
            } else if (!newName) {
                alert("Please enter a valid character name.");
            }
        }

        function modifyAttribute(attribute, change) {
            if (!player) {
                alert("Please create a character first!");
                return;
            }
            
            // Calculate total current attributes
            const currentTotal = Object.values(player.attributes).reduce((sum, val) => sum + val, 0);
            const maxTotal = 300; // Maximum total attribute points
            const maxPerAttribute = 150; // Maximum per attribute
            
            let newValue = player.attributes[attribute] + change;
            
            // Check if increasing would exceed total cap
            if (change > 0 && (currentTotal - player.attributes[attribute] + newValue) > maxTotal) {
                alert(`Cannot increase ${attribute}. Total attribute points cannot exceed ${maxTotal}.`);
                return;
            }
            
            // Check individual attribute cap
            if (change > 0 && newValue > maxPerAttribute) {
                alert(`Cannot increase ${attribute}. Individual attribute cannot exceed ${maxPerAttribute}.`);
                return;
            }
            
            newValue = Math.max(0, Math.min(maxPerAttribute, newValue)); // Individual attribute cap is 150
            player.attributes[attribute] = newValue;
            
            // Recalculate health if vitality changed
            if (attribute === 'Vitality') {
                recalculateHealth();
            }
            
            updateCharacterDisplay();
            saveGameData();
        }

        function updateCharacterDisplay() {
            if (player) {
                // Show character display section, hide creation section
                document.getElementById('character-display-section').style.display = 'block';
                document.getElementById('no-character-section').style.display = 'none';
                
                // Update character name displays (with null checks)
                const displayedNameEl = document.getElementById('displayed-name');
                if (displayedNameEl) displayedNameEl.textContent = player.name;
                const charNameEditEl = document.getElementById('char-name-edit');
                if (charNameEditEl) charNameEditEl.value = player.name;
                const charNameInputEl = document.getElementById('char-name-input');
                if (charNameInputEl) charNameInputEl.value = player.name;
                    
                    // Update character tier/rank display with prestige
                    const tier = calculateCharacterTier();
                    const rank = getCharacterRank(tier);
                    const prestigeLevel = gameData.prestige.level;
                    const prestigeText = prestigeLevel > 0 ? ` | Prestige ${prestigeLevel}` : '';
                    const charLevelEl = document.getElementById('char-level');
                    if (charLevelEl) charLevelEl.textContent = `${rank} (Tier ${tier})${prestigeText}`;
                    
                    // Show/hide prestige button
                    const prestigeBtn = document.getElementById('prestige-btn');
                    if (prestigeBtn) {
                        if (canPrestige()) {
                            prestigeBtn.style.display = 'inline-block';
                        } else {
                            prestigeBtn.style.display = 'none';
                        }
                    }
                
                // Update attributes
                // Calculate equipment bonuses
                const equipmentBonuses = calculateEquipmentBonuses();
                
                // Display attributes with equipment bonuses (with null checks)
                const powerDisplay = player.attributes.Power.toFixed(1);
                const powerBonus = equipmentBonuses.Power || 0;
                const charPowerEl = document.getElementById('char-power');
                if (charPowerEl) {
                    charPowerEl.innerHTML = powerBonus > 0 
                        ? `${powerDisplay} <span style="color: #48bb78; font-size: 0.9em;">+${powerBonus.toFixed(1)}</span>`
                        : powerDisplay;
                }
                
                const dexDisplay = player.attributes.Dexterity.toFixed(1);
                const dexBonus = equipmentBonuses.Dexterity || 0;
                const charDexEl = document.getElementById('char-dex');
                if (charDexEl) {
                    charDexEl.innerHTML = dexBonus > 0 
                        ? `${dexDisplay} <span style="color: #48bb78; font-size: 0.9em;">+${dexBonus.toFixed(1)}</span>`
                        : dexDisplay;
                }
                
                const vitDisplay = player.attributes.Vitality.toFixed(1);
                const vitBonus = equipmentBonuses.Vitality || 0;
                const charVitEl = document.getElementById('char-vit');
                if (charVitEl) {
                    charVitEl.innerHTML = vitBonus > 0 
                        ? `${vitDisplay} <span style="color: #48bb78; font-size: 0.9em;">+${vitBonus.toFixed(1)}</span>`
                        : vitDisplay;
                }
                const charHpEl = document.getElementById('char-hp');
                if (charHpEl) charHpEl.textContent = `${player.hp.toFixed(1)}/${player.maxHp.toFixed(1)}`;
                
                // Calculate combat stats
                const combatStats = calculateCombatStats();
                const damageRangeEl = document.getElementById('damage-range');
                if (damageRangeEl) damageRangeEl.textContent = `${combatStats.damageMin} - ${combatStats.damageMax}`;
                const damageTypeEl = document.getElementById('damage-type');
                if (damageTypeEl) damageTypeEl.textContent = combatStats.damageType.charAt(0).toUpperCase() + combatStats.damageType.slice(1);
                const attackRatingEl = document.getElementById('attack-rating');
                if (attackRatingEl) attackRatingEl.textContent = combatStats.attackRating;
                const critChanceEl = document.getElementById('crit-chance');
                if (critChanceEl) critChanceEl.textContent = combatStats.critChance.toFixed(1) + '%';
                const totalArmorEl = document.getElementById('total-armor');
                if (totalArmorEl) totalArmorEl.textContent = combatStats.armor;
                const totalMagicResistEl = document.getElementById('total-magic-resist');
                if (totalMagicResistEl) totalMagicResistEl.textContent = combatStats.magicResist;
                const blockChanceEl = document.getElementById('block-chance');
                if (blockChanceEl) blockChanceEl.textContent = combatStats.blockChance.toFixed(1) + '%';
                const parryChanceEl = document.getElementById('parry-chance');
                if (parryChanceEl) parryChanceEl.textContent = combatStats.parryChance.toFixed(1) + '%';
                const dodgeChanceEl = document.getElementById('dodge-chance');
                if (dodgeChanceEl) dodgeChanceEl.textContent = combatStats.dodgeChance.toFixed(1) + '%';
                const firstAidValueEl = document.getElementById('first-aid-value');
                if (firstAidValueEl) firstAidValueEl.textContent = combatStats.firstAidValue.toFixed(1) + ' HP/turn';
                const restorationValueEl = document.getElementById('restoration-value');
                if (restorationValueEl) restorationValueEl.textContent = combatStats.restorationValue.toFixed(1) + '% max HP';
                
                // Update equipped items (with null checks)
                const updateEquippedItem = (id, item) => {
                    const el = document.getElementById(id);
                    if (el) el.textContent = item ? item.name : 'None';
                };
                updateEquippedItem('equipped-helmet-display', gameData.equipment.helmet);
                updateEquippedItem('equipped-shoulders-display', gameData.equipment.shoulders);
                updateEquippedItem('equipped-chest-display', gameData.equipment.chest);
                updateEquippedItem('equipped-bracers-display', gameData.equipment.bracers);
                updateEquippedItem('equipped-gloves-display', gameData.equipment.gloves);
                updateEquippedItem('equipped-ring1-display', gameData.equipment.ring1);
                updateEquippedItem('equipped-ring2-display', gameData.equipment.ring2);
                updateEquippedItem('equipped-necklace-display', gameData.equipment.necklace);
                updateEquippedItem('equipped-cape-display', gameData.equipment.cape);
                updateEquippedItem('equipped-belt-display', gameData.equipment.belt);
                updateEquippedItem('equipped-pants-display', gameData.equipment.pants);
                updateEquippedItem('equipped-boots-display', gameData.equipment.boots);
                updateEquippedItem('equipped-ring3-display', gameData.equipment.ring3);
                updateEquippedItem('equipped-ring4-display', gameData.equipment.ring4);
                updateEquippedItem('equipped-mainhand-display', gameData.equipment.mainhand);
                updateEquippedItem('equipped-offhand-display', gameData.equipment.offhand);
                updateEquippedItem('equipped-trinket1-display', gameData.equipment.trinket1);
                updateEquippedItem('equipped-trinket2-display', gameData.equipment.trinket2);
                
                // Update skills with proper ID mapping
                const skillIdMap = {
                    'Concentration': 'concentration',
                    'Defense': 'defense',
                    'Blocking': 'blocking',
                    'Parrying': 'parrying',
                    'Anatomy': 'anatomy',
                    'Dodging': 'dodging',
                    'FuryControl': 'furycontrol',
                    'Provocation': 'provocation',
                    'Swordsmanship': 'swordsmanship',
                    'CombatTactics': 'combattactics',
                    'MaceFighting': 'macefighting',
                    'CloseCombat': 'closecombat',
                    'FireDominance': 'firedominance',
                    'FrostDominance': 'frostdominance',
                    'DarkKnowledge': 'darkknowledge',
                    'HolyWisdom': 'holywisdom',
                    'MagicFocus': 'magicfocus',
                    'SpiritControl': 'spiritcontrol',
                    'SilentDiscipline': 'silentdiscipline',
                    'MagicResist': 'magicresist',
                    'FirstAid': 'firstaid',
                    'Restoration': 'restoration',
                    'Endurance': 'endurance'
                };
                
                Object.keys(gameData.skills).forEach(skill => {
                    const skillId = skillIdMap[skill] || skill.toLowerCase();
                    const element = document.getElementById(`skill-${skillId}`);
                    if (element) {
                        element.textContent = gameData.skills[skill].toFixed(1);
                    }
                });
                
                // Show character display section, hide no-character section
                document.getElementById('character-display-section').style.display = 'block';
                document.getElementById('no-character-section').style.display = 'none';
                
                // Update toggle buttons and currency
                updateToggleButtons();
                updateCurrencyDisplay();
                
                    // Enable attribute buttons
                    const attrButtons = ['power-decrease', 'power-increase', 'power-lock', 
                                         'dex-decrease', 'dex-increase', 'dex-lock',
                                         'vit-decrease', 'vit-increase', 'vit-lock'];
                    attrButtons.forEach(btnId => {
                        const btn = document.getElementById(btnId);
                        if (btn) btn.disabled = false;
                    });
                    
                    // Update toggle button states for attributes
                    updateToggleButtonState('Power', gameData.attributeToggles.Power);
                    updateToggleButtonState('Dexterity', gameData.attributeToggles.Dexterity);
                    updateToggleButtonState('Vitality', gameData.attributeToggles.Vitality);
            } else {
                // Show default values and no-character section (with null checks)
                const updateIfExists = (id, value) => {
                    const el = document.getElementById(id);
                    if (el) el.textContent = value;
                };
                updateIfExists('displayed-name', 'Adventurer');
                const charNameEditEl2 = document.getElementById('char-name-edit');
                if (charNameEditEl2) charNameEditEl2.value = '';
                const charNameInputEl2 = document.getElementById('char-name-input');
                if (charNameInputEl2) charNameInputEl2.value = '';
                updateIfExists('char-power', '0.0');
                updateIfExists('char-dex', '0.0');
                updateIfExists('char-vit', '0.0');
                updateIfExists('char-hp', '100/100');
                updateIfExists('total-attack', '50');
                updateIfExists('total-defense', '50');
                updateIfExists('equipped-weapon-display', 'None');
                updateIfExists('equipped-armor-display', 'None');
                updateIfExists('equipped-accessory-display', 'None');
                
                // Reset skills
                Object.keys(gameData.skills).forEach(skill => {
                    const element = document.getElementById(`skill-${skill.toLowerCase()}`);
                    if (element) {
                        element.textContent = '0.0';
                    }
                });
                
                // Show no-character section, hide character display section
                document.getElementById('no-character-section').style.display = 'block';
                document.getElementById('character-display-section').style.display = 'none';
                
                // Enable and focus the name input field
                setTimeout(() => {
                    const nameInput = document.getElementById('char-name-input');
                    if (nameInput) {
                        nameInput.disabled = false;
                        nameInput.readOnly = false;
                        nameInput.removeAttribute('disabled');
                        nameInput.removeAttribute('readonly');
                        nameInput.style.pointerEvents = 'auto';
                        nameInput.style.opacity = '1';
                        nameInput.focus();
                        nameInput.select();
                    }
                }, 100);
                
                // Disable attribute buttons when no character
                const attrButtons = ['power-decrease', 'power-increase', 'power-lock', 
                                     'dex-decrease', 'dex-increase', 'dex-lock',
                                     'vit-decrease', 'vit-increase', 'vit-lock'];
                attrButtons.forEach(btnId => {
                    const btn = document.getElementById(btnId);
                    if (btn) btn.disabled = true;
                });
            }
        }

    function calculateTotalSkills() {
        const totalSkills = { ...gameData.skills };
        
        // Add equipment skill bonuses
        Object.values(gameData.equipment).forEach(item => {
            if (item && item.skills) {
                Object.keys(item.skills).forEach(skill => {
                    totalSkills[skill] = (totalSkills[skill] || 0) + item.skills[skill];
                });
            }
        });
        
        return totalSkills;
    }

    // Calculate character tier based on total attributes and skills
    // Tier 1: 0-50 total attributes + 0-150 total skills
    // Tier 2: 51-100 total attributes + 151-300 total skills  
    // Tier 3: 101-150 total attributes + 301-450 total skills
    // Tier 4: 151-200 total attributes + 451-600 total skills
        // New exponential progression system
        function calculateAttributeGain(baseGain, currentValue, prestigeLevel = 0) {
            // Exponential scaling: gains decrease as values increase
            const scalingFactor = Math.max(0.01, Math.pow(0.95, currentValue / 10));
            const prestigeBonus = 1 + (prestigeLevel * 0.1); // 10% bonus per prestige level
            
            // Apply seasonal modifiers
            const seasonalModifiers = getSeasonalModifiers();
            const seasonalBonus = seasonalModifiers.attributeGainMultiplier || 1.0;
            
            return baseGain * scalingFactor * prestigeBonus * seasonalBonus;
        }

        function calculateSkillGain(baseGain, currentValue, prestigeLevel = 0) {
            // Similar exponential scaling for skills
            const scalingFactor = Math.max(0.01, Math.pow(0.95, currentValue / 10));
            const prestigeBonus = 1 + (prestigeLevel * 0.1);
            
            // Apply seasonal modifiers
            const seasonalModifiers = getSeasonalModifiers();
            const seasonalBonus = seasonalModifiers.skillGainMultiplier || 1.0;
            
            return baseGain * scalingFactor * prestigeBonus * seasonalBonus;
        }

        function canPrestige() {
            if (!player) return false;
            const totalAttributes = Object.values(player.attributes).reduce((sum, val) => sum + val, 0);
            const totalSkills = Object.values(gameData.skills).reduce((sum, val) => sum + val, 0);
            
            // Can prestige when reaching high levels
            return totalAttributes >= 150 && totalSkills >= 400;
        }

        function performPrestige() {
            if (!canPrestige()) return false;
            
            const totalAttributes = Object.values(player.attributes).reduce((sum, val) => sum + val, 0);
            const totalSkills = Object.values(gameData.skills).reduce((sum, val) => sum + val, 0);
            
            // Calculate prestige points based on total progression
            const prestigePoints = Math.floor((totalAttributes + totalSkills) / 10);
            
            // Reset character but keep prestige bonuses
            gameData.prestige.level++;
            gameData.prestige.points += prestigePoints;
            gameData.prestige.totalPrestigePoints += prestigePoints;
            
            // Apply prestige bonuses
            gameData.prestige.bonuses.attributeMultiplier += 0.1;
            gameData.prestige.bonuses.skillMultiplier += 0.1;
            gameData.prestige.bonuses.experienceMultiplier += 0.05;
            gameData.prestige.bonuses.goldMultiplier += 0.05;
            gameData.prestige.bonuses.dropRateMultiplier += 0.02;
            
            // Reset character stats
            player.attributes = { Power: 0, Dexterity: 0, Vitality: 0 };
            Object.keys(gameData.skills).forEach(skill => {
                gameData.skills[skill] = 0;
            });
            
            // Reset equipment
            Object.keys(gameData.equipment).forEach(slot => {
                gameData.equipment[slot] = null;
            });
            
            // Keep some gold and items
            gameData.currency.gold = Math.max(100, Math.floor(gameData.currency.gold * 0.1));
            
            // Update prestige achievement progress
            updateAchievementProgress('prestigeLevels');
            updateAchievementProgress('prestigeCompleted');
            
            // Check challenge progress
            checkChallengeProgress();
            
            return true;
        }

        // Updated tier calculation with prestige
        function calculateCharacterTier() {
            if (!player) return 1;
            
            const totalAttributes = Object.values(player.attributes).reduce((sum, val) => sum + val, 0);
            const totalSkills = Object.values(gameData.skills).reduce((sum, val) => sum + val, 0);
            const prestigeLevel = gameData.prestige.level;
            
            // Calculate tier based on combined progression + prestige
            const baseProgress = (totalAttributes / 200) + (totalSkills / 600);
            const prestigeBonus = prestigeLevel * 0.5; // Each prestige adds 0.5 to tier calculation
            const tier = Math.min(10, Math.max(1, Math.ceil((baseProgress + prestigeBonus) * 2.5)));
            
            return tier;
        }

    // Get character rank name based on tier
    function getCharacterRank(tier) {
        const ranks = {
            1: "Novice",
            2: "Apprentice", 
            3: "Adept",
            4: "Expert",
            5: "Master",
            6: "Grandmaster",
            7: "Legend",
            8: "Mythic",
            9: "Transcendent",
            10: "Ascendant"
        };
        return ranks[tier] || "Unknown";
    }

        // Calculate equipment bonuses only (for display)
        function calculateEquipmentBonuses() {
            const bonuses = { Power: 0, Dexterity: 0, Vitality: 0 };
            
            Object.values(gameData.equipment).forEach(item => {
                if (item && item.stats) {
                    if (item.stats.Power) bonuses.Power += item.stats.Power;
                    if (item.stats.Dexterity) bonuses.Dexterity += item.stats.Dexterity;
                    if (item.stats.Vitality) bonuses.Vitality += item.stats.Vitality;
                }
            });
            
            return bonuses;
        }
        
        // Recalculate player health based on Vitality (base + equipment) and Endurance skill
        // Enforce skill caps (100 per skill, 600 total)
        function enforceSkillCaps() {
            const maxPerSkill = 100;
            const maxTotal = 600;
            
            // First, cap individual skills at 100
            Object.keys(gameData.skills).forEach(skill => {
                if (gameData.skills[skill] > maxPerSkill) {
                    gameData.skills[skill] = maxPerSkill;
                }
            });
            
            // Then, if total exceeds 600, reduce skills proportionally
            const currentTotal = Object.values(gameData.skills).reduce((sum, val) => sum + val, 0);
            if (currentTotal > maxTotal) {
                const reductionFactor = maxTotal / currentTotal;
                Object.keys(gameData.skills).forEach(skill => {
                    gameData.skills[skill] = Math.floor(gameData.skills[skill] * reductionFactor * 100) / 100;
                });
            }
        }
        
        function recalculateHealth() {
            if (!player) return;
            
            const baseHealth = 50;
            
            // Get total Vitality including equipment bonuses
            const equipmentBonuses = calculateEquipmentBonuses();
            const totalVitality = player.attributes.Vitality + equipmentBonuses.Vitality;
            
            // Endurance skill bonus: 2 HP per Endurance skill point
            const enduranceBonus = gameData.skills.Endurance * 2;
            
            // Round to nearest tenth to avoid long decimals
            player.maxHp = Math.round((baseHealth + totalVitality + enduranceBonus) * 10) / 10;
            player.hp = Math.min(Math.round(player.hp * 10) / 10, player.maxHp);
        }
        
        // Prompt user to select ring slot
        function promptRingSlot(ringSlots, newRing) {
            let message = `Select which ring slot to equip "${newRing.name}":\n\n`;
            ringSlots.forEach((slot, index) => {
                const currentRing = slot.item ? slot.item.name : 'Empty';
                message += `${index + 1}. ${slot.name}: ${currentRing}\n`;
            });
            message += `\nEnter 1-4 to select a slot (or Cancel to cancel):`;
            
            let choice = prompt(message);
            if (choice === null) return null;
            
            const slotIndex = parseInt(choice) - 1;
            if (slotIndex >= 0 && slotIndex < 4) {
                return ringSlots[slotIndex].key;
            }
            
            alert('Invalid selection. Please try again.');
            return promptRingSlot(ringSlots, newRing); // Retry
        }
        
        function calculateTotalStats() {
            if (!player) return { Power: 0, Dexterity: 0, Vitality: 0 };
            
            const base = { ...player.attributes };
            const totalSkills = calculateTotalSkills();
            
            // Add equipment bonuses from stats
            Object.values(gameData.equipment).forEach(item => {
                if (item && item.stats) {
                    Object.keys(item.stats).forEach(stat => {
                        base[stat] = (base[stat] || 0) + item.stats[stat];
                    });
                }
            });
            
            // Add skill bonuses based on attribute dependencies
            // Power-based skills
            base.Power += totalSkills.Concentration * 0.3;
            base.Power += totalSkills.Defense * 0.2;
            base.Power += totalSkills.Blocking * 0.25;
            base.Power += totalSkills.Parrying * 0.3;
            base.Power += totalSkills.Anatomy * 0.4;
            
            // Dexterity-based skills
            base.Dexterity += totalSkills.Dodging * 0.3;
            base.Dexterity += totalSkills.FuryControl * 0.25;
            base.Dexterity += totalSkills.Provocation * 0.2;
            base.Dexterity += totalSkills.Swordsmanship * 0.4;
            base.Dexterity += totalSkills.CombatTactics * 0.35;
            base.Dexterity += totalSkills.MaceFighting * 0.4;
            base.Dexterity += totalSkills.CloseCombat * 0.4;
            base.Dexterity += totalSkills.FireDominance * 0.3;
            base.Dexterity += totalSkills.FrostDominance * 0.3;
            base.Dexterity += totalSkills.DarkKnowledge * 0.3;
            base.Dexterity += totalSkills.HolyWisdom * 0.3;
            base.Dexterity += totalSkills.MagicFocus * 0.35;
            base.Dexterity += totalSkills.SpiritControl * 0.25;
            base.Dexterity += totalSkills.SilentDiscipline * 0.2;
            base.Dexterity += totalSkills.MagicResist * 0.2;
            
            // Vitality-based skills
            base.Vitality += totalSkills.FirstAid * 0.3;
            base.Vitality += totalSkills.Restoration * 0.4;
            base.Vitality += totalSkills.Endurance * 0.5;
            
            return base;
        }
        
        function calculateCombatStats() {
            if (!player) return {};
            
            const totalStats = calculateTotalStats();
            const totalSkills = calculateTotalSkills();
            let totalArmor = 0;
            let totalMagicResist = 0;
            let damageMin = totalStats.Power;
            let damageMax = totalStats.Power * 1.2;
            let damageType = "physical";
            
            // Calculate equipment bonuses
            Object.values(gameData.equipment).forEach(item => {
                if (item) {
                    if (item.armor) totalArmor += item.armor;
                    if (item.magicResist) totalMagicResist += item.magicResist;
                    if (item.damageType) damageType = item.damageType;
                }
            });
            
            // Calculate combat stats using total skills (including equipment)
            const attackRating = totalStats.Dexterity + totalSkills.CombatTactics + totalSkills.MagicFocus;
            const critChance = (totalSkills.FuryControl + totalSkills.SpiritControl) * 0.1;
            
            // Apply diminishing returns to Blocking and Dodging
            const blockChance = Math.min(totalSkills.Blocking * 0.2, 75); // Cap at 75%
            const parryChance = totalSkills.Parrying * 0.15;
            const dodgeChance = Math.min(totalSkills.Dodging * 0.25, 80); // Cap at 80%
            
            const firstAidValue = totalSkills.FirstAid * 0.5;
            const restorationValue = totalSkills.Restoration * 0.5; // Percentage of max HP (0.5% per skill point)
            const defenseValue = totalSkills.Defense * 0.1; // Reduces physical damage by 0.1 per Defense skill point
            
            // Add Magic Resist skill bonus
            totalMagicResist += totalSkills.MagicResist * 0.5; // 0.5 Magic Resist per skill point
            
            return {
                damageMin: Math.floor(damageMin),
                damageMax: Math.floor(damageMax),
                damageType: damageType,
                attackRating: Math.floor(attackRating),
                critChance: Math.floor(critChance * 100) / 100,
                armor: totalArmor,
                magicResist: Math.floor(totalMagicResist),
                blockChance: Math.floor(blockChance * 100) / 100,
                parryChance: Math.floor(parryChance * 100) / 100,
                dodgeChance: Math.floor(dodgeChance * 100) / 100,
                firstAidValue: Math.floor(firstAidValue * 100) / 100,
                restorationValue: Math.floor(restorationValue * 100) / 100,
                defenseValue: Math.floor(defenseValue * 100) / 100
            };
        }

        function modifySkill(skillName, change) {
            if (!player) {
                alert("Please create a character first!");
                return;
            }
            
            // Calculate total current skills
            const currentTotal = Object.values(gameData.skills).reduce((sum, val) => sum + val, 0);
            const maxTotal = 600; // Maximum total skill points
            
            let newValue = gameData.skills[skillName] + change;
            
            // Check if increasing would exceed total cap
            if (change > 0 && (currentTotal - gameData.skills[skillName] + newValue) > maxTotal) {
                alert(`Cannot increase ${skillName}. Total skill points cannot exceed ${maxTotal}.`);
                return;
            }
            
            newValue = Math.max(0, Math.min(100, newValue)); // Individual skill cap is 100
            gameData.skills[skillName] = newValue;
            
            updateCharacterDisplay();
        }

        // Duplicate toggleSkill removed - using the one defined earlier

        function updateToggleButtonState(name, state) {
            // Find all toggle buttons for this skill (Primary or Secondary)
            // All skills now use data-skill attribute for consistency
            const buttons = document.querySelectorAll(`[data-skill="${name}"]`);
            
            buttons.forEach(button => {
                button.classList.remove('active');
                if (button.dataset.state === state) {
                    button.classList.add('active');
                }
            });
        }

        function updateToggleButtons() {
            // Update skill toggle buttons
            Object.keys(gameData.skillToggles).forEach(skill => {
                updateToggleButtonState(skill, gameData.skillToggles[skill]);
            });
            
            // Update attribute toggle buttons
            Object.keys(gameData.attributeToggles).forEach(attr => {
                updateToggleButtonState(attr, gameData.attributeToggles[attr]);
            });
        }

        // Idle Combat System
        function startIdleCombat(locationId) {
            // Idle combat disabled - combat must be earned through active gameplay
            console.log("Idle combat is disabled. Combat must be earned through active gameplay.");
            alert("Idle combat has been disabled. Combat and experience must be earned through active gameplay.");
            return;
            
            if (!player) {
                alert("Please create a character first!");
                return;
            }
            
            gameData.idleCombat.isActive = true;
            gameData.idleCombat.location = locationId;
            gameData.idleCombat.startTime = Date.now();
            gameData.idleCombat.battlesCompleted = 0;
            
            // Clear combat log
            document.getElementById('log-content').innerHTML = '<div>Starting idle combat...</div>';
            
            // Start the first battle
            startNewCombat();
            
            saveGameData();
            console.log(`Started idle combat in ${gameData.locations[locationId].name}`);
        }

        function stopIdleCombat() {
            gameData.idleCombat.isActive = false;
            gameData.idleCombat.location = null;
            gameData.idleCombat.startTime = null;
            
            combatState = null;
            battleTurnCount = 0; // Reset turn counter
            updateCombatDisplay();
            
            addCombatLog("Idle combat stopped.");
            saveGameData();
            console.log("Stopped idle combat");
        }

        function calculateOfflineProgression() {
            // Idle combat disabled - combat must be earned through active gameplay
            return null;
            
            if (!gameData.idleCombat.lastSaveTime) {
                return null;
            }
            
            const now = Date.now();
            const timeElapsed = now - gameData.idleCombat.lastSaveTime;
            const maxOfflineTime = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
            
            // Cap offline time at 24 hours
            const actualOfflineTime = Math.min(timeElapsed, maxOfflineTime);
            
            if (actualOfflineTime < 60000) { // Less than 1 minute
                return null;
            }
            
            // Calculate battles that would have completed offline
            const battleInterval = 5000; // 5 seconds per battle
            const battlesCompleted = Math.floor(actualOfflineTime / battleInterval);
            
            // Calculate progression
            const offlineProgress = {
                timeElapsed: actualOfflineTime,
                battlesCompleted: battlesCompleted,
                monstersDefeated: battlesCompleted,
                attributeGains: {},
                skillGains: {},
                itemsFound: []
            };
            
            // Apply attribute changes with new exponential system
            Object.keys(gameData.attributeToggles).forEach(attr => {
                const toggleState = gameData.attributeToggles[attr];
                if (toggleState === 'increase') {
                    let totalGain = 0;
                    for (let i = 0; i < battlesCompleted; i++) {
                        const gain = calculateAttributeGain(0.1, player.attributes[attr], gameData.prestige.level);
                        totalGain += gain;
                    }
                    player.attributes[attr] += totalGain;
                    if (totalGain > 0) {
                        offlineProgress.attributeGains[attr] = totalGain;
                    }
                } else if (toggleState === 'decrease') {
                    let totalLoss = 0;
                    for (let i = 0; i < battlesCompleted; i++) {
                        const loss = calculateAttributeGain(0.1, player.attributes[attr], gameData.prestige.level);
                        totalLoss += loss;
                    }
                    player.attributes[attr] = Math.max(0, player.attributes[attr] - totalLoss);
                    offlineProgress.attributeGains[attr] = -totalLoss;
                }
            });
            
            // Apply skill changes with new exponential system
            Object.keys(gameData.skillToggles).forEach(skill => {
                const toggleState = gameData.skillToggles[skill];
                if (toggleState === 'increase') {
                    let totalGain = 0;
                    const currentTotal = Object.values(gameData.skills).reduce((sum, val) => sum + val, 0);
                    const maxTotal = 600;
                    const currentSkillValue = gameData.skills[skill];
                    
                    for (let i = 0; i < battlesCompleted; i++) {
                        // Check if we've hit the total cap
                        if (currentTotal + totalGain >= maxTotal) {
                            break;
                        }
                        
                        const gain = calculateSkillGain(0.1, currentSkillValue + totalGain, gameData.prestige.level);
                        const newSkillValue = currentSkillValue + totalGain + gain;
                        
                        // Check individual skill cap (100) and total cap (600)
                        if (newSkillValue <= 100 && (currentTotal + totalGain + gain) <= maxTotal) {
                            totalGain += gain;
                        } else {
                            // Cap reached, stop gaining
                            break;
                        }
                    }
                    
                    if (totalGain > 0) {
                        gameData.skills[skill] = Math.min(100, currentSkillValue + totalGain);
                        offlineProgress.skillGains[skill] = totalGain;
                    }
                } else if (toggleState === 'decrease') {
                    let totalLoss = 0;
                    for (let i = 0; i < battlesCompleted; i++) {
                        const loss = calculateSkillGain(0.1, gameData.skills[skill], gameData.prestige.level);
                        totalLoss += loss;
                    }
                    gameData.skills[skill] = Math.max(0, gameData.skills[skill] - totalLoss);
                    offlineProgress.skillGains[skill] = -totalLoss;
                }
            });
            
            // Calculate item drops (40% chance per battle) - zone-specific
            if (gameData.idleCombat.location && gameData.locations[gameData.idleCombat.location]) {
                const location = gameData.locations[gameData.idleCombat.location];
                if (location.uniqueLoot && location.uniqueLoot.length > 0) {
                    const zoneBaseItems = baseItems.filter(item => 
                        item.zones && item.zones.includes(location.uniqueLoot[0])
                    );
                    
                    for (let i = 0; i < battlesCompleted; i++) {
                        // Check for super rare unique drops first (0.001% = 0.00001 chance)
                        const uniqueItems = baseItems.filter(item => 
                            item.isUnique && item.zones && item.zones.includes(location.uniqueLoot[0])
                        );
                        if (uniqueItems.length > 0 && Math.random() < 0.00001) {
                            const uniqueItem = uniqueItems[Math.floor(Math.random() * uniqueItems.length)];
                            const newUniqueItem = generateRandomItem(uniqueItem);
                            gameData.inventory.push(newUniqueItem);
                            offlineProgress.itemsFound.push(`[UNIQUE] ${newUniqueItem.name}`);
                            updateAchievementProgress('itemsFound');
                            continue; // Skip regular drop for this battle
                        }
                        
                        // Regular item drops (40% chance)
                        if (Math.random() < 0.4 && zoneBaseItems.length > 0) {
                            const randomBaseItem = zoneBaseItems[Math.floor(Math.random() * zoneBaseItems.length)];
                            const newItem = generateRandomItem(randomBaseItem);
                            gameData.inventory.push(newItem);
                            offlineProgress.itemsFound.push(newItem.name);
                            updateAchievementProgress('itemsFound');
                        }
                        
                        // Material drops (30% chance)
                        if (Math.random() < 0.3) {
                            const materials = getZoneMaterials(location.uniqueLoot[0]);
                            const materialType = materials[Math.floor(Math.random() * materials.length)];
                            gameData.crafting.materials[materialType] += 1;
                            updateAchievementProgress('materialsCollected');
                        }
                    }
                }
            }
            
                // Update player experience
                player.experience += battlesCompleted * 10;
                
                // Check for tier advancement
                const tier = calculateCharacterTier();
                const rank = getCharacterRank(tier);
            
            // Recalculate health if vitality changed
            if (gameData.attributeToggles.Vitality !== 'lock') {
                recalculateHealth(); // Use centralized function to ensure consistency
            }
            
            return offlineProgress;
        }

        function showOfflineProgressSummary(progress) {
            const timeElapsed = Math.floor(progress.timeElapsed / 60000); // Convert to minutes
            
            let summaryText = `
                <h3>Welcome Back!</h3>
                <p><strong>Time Away:</strong> ${timeElapsed} minutes</p>
                <p><strong>Battles Completed:</strong> ${progress.battlesCompleted}</p>
                <p><strong>Monsters Defeated:</strong> ${progress.monstersDefeated}</p>
            `;
            
            // Show attribute gains
            if (Object.keys(progress.attributeGains).length > 0) {
                summaryText += `<p><strong>Attribute Changes:</strong></p><ul>`;
                Object.keys(progress.attributeGains).forEach(attr => {
                    const gain = progress.attributeGains[attr];
                    summaryText += `<li>${attr}: ${gain > 0 ? '+' : ''}${gain.toFixed(1)}</li>`;
                });
                summaryText += `</ul>`;
            }
            
            // Show skill gains
            if (Object.keys(progress.skillGains).length > 0) {
                summaryText += `<p><strong>Skill Changes:</strong></p><ul>`;
                Object.keys(progress.skillGains).forEach(skill => {
                    const gain = progress.skillGains[skill];
                    summaryText += `<li>${skill}: ${gain > 0 ? '+' : ''}${gain.toFixed(1)}</li>`;
                });
                summaryText += `</ul>`;
            }
            
            // Show items found (grouped by name)
            if (progress.itemsFound.length > 0) {
                summaryText += `<p><strong>Items Found:</strong></p><ul>`;
                
                // Group items by name and count
                const itemCounts = {};
                progress.itemsFound.forEach(itemName => {
                    itemCounts[itemName] = (itemCounts[itemName] || 0) + 1;
                });
                
                // Display grouped items
                Object.entries(itemCounts).forEach(([itemName, count]) => {
                    if (count > 1) {
                        summaryText += `<li>${itemName} x ${count}</li>`;
                    } else {
                        summaryText += `<li>${itemName}</li>`;
                    }
                });
                
                summaryText += `</ul>`;
            }
            
            // Create styled modal instead of alert
            showStyledModal('Welcome Back!', summaryText);
        }
        
        // Styled Modal System
        function showStyledModal(title, content) {
            // Remove existing modal if present
            const existingModal = document.getElementById('styled-modal');
            if (existingModal) {
                existingModal.remove();
            }
            
            // Create modal overlay
            const modalOverlay = document.createElement('div');
            modalOverlay.id = 'styled-modal';
            modalOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
            `;
            
            // Create modal content
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: linear-gradient(180deg, #f4e4c1 0%, #e8d5b7 100%);
                border: 3px solid #8b7355;
                border-radius: 12px;
                padding: 2rem;
                max-width: 600px;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8), inset 0 1px 0 rgba(255, 255, 255, 0.3);
                color: #1a1a1a;
                position: relative;
            `;
            
            // Modal title
            const modalTitle = document.createElement('h2');
            modalTitle.textContent = title;
            modalTitle.style.cssText = `
                color: #8b4513;
                margin: 0 0 1rem 0;
                text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
                border-bottom: 2px solid #8b7355;
                padding-bottom: 0.5rem;
            `;
            
            // Modal body
            const modalBody = document.createElement('div');
            modalBody.innerHTML = content;
            modalBody.style.cssText = `
                color: #2d1b0e;
                line-height: 1.6;
            `;
            
            // Close button
            const closeBtn = document.createElement('button');
            closeBtn.textContent = 'OK';
            closeBtn.className = 'btn btn-primary';
            closeBtn.style.cssText = `
                margin-top: 1.5rem;
                width: 100%;
            `;
            closeBtn.onclick = () => {
                modalOverlay.remove();
            };
            
            modalContent.appendChild(modalTitle);
            modalContent.appendChild(modalBody);
            modalContent.appendChild(closeBtn);
            modalOverlay.appendChild(modalContent);
            
            // Close on overlay click
            modalOverlay.onclick = (e) => {
                if (e.target === modalOverlay) {
                    modalOverlay.remove();
                }
            };
            
            document.body.appendChild(modalOverlay);
        }

        // Inventory filtering and sorting
        function filterInventoryByCategory(category) {
            currentInventoryFilter = category;
            
            // Update filter button states
            document.querySelectorAll('.item-category-tabs .tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            const filterBtn = document.getElementById(`filter-${category}`);
            if (filterBtn) {
                filterBtn.classList.add('active');
            }
            
            updateInventoryDisplay();
        }
        
        function sortInventory() {
            const sortSelect = document.getElementById('inventory-sort');
            if (sortSelect) {
                currentInventorySort = sortSelect.value;
            }
            updateInventoryDisplay();
        }
        
        // Inventory management
        function updateInventoryDisplay() {
            const grid = document.getElementById('inventory-grid');
            if (!grid) return; // Function called but inventory screen not loaded
            
            grid.innerHTML = '';
            
            // Filter items by category
            let filteredItems = gameData.inventory;
            if (currentInventoryFilter !== 'all') {
                filteredItems = gameData.inventory.filter(item => {
                    if (currentInventoryFilter === 'weapon') {
                        // Weapons: mainhand, offhand (if weapon type)
                        return item.type === 'weapon' || item.slot === 'mainhand' || (item.slot === 'offhand' && item.type === 'weapon');
                    } else if (currentInventoryFilter === 'armor') {
                        // Armor: helmet, shoulders, chest, bracers, gloves, pants, boots, cape, belt, offhand (if shield)
                        return item.type === 'armor' || 
                               ['helmet', 'shoulders', 'chest', 'bracers', 'gloves', 'pants', 'boots', 'cape', 'belt'].includes(item.slot) ||
                               (item.slot === 'offhand' && item.name && item.name.toLowerCase().includes('shield'));
                    } else if (currentInventoryFilter === 'accessory') {
                        // Accessories: rings, necklaces, trinkets
                        return item.type === 'accessory' || 
                               item.slot === 'ring' || 
                               item.slot === 'necklace' || 
                               item.slot === 'trinket' ||
                               (item.category === 'jewelry');
                    }
                    return true;
                });
            }
            
            // Sort items
            filteredItems = [...filteredItems].sort((a, b) => {
                switch(currentInventorySort) {
                    case 'power':
                        const aPower = (a.stats && a.stats.Power) || 0;
                        const bPower = (b.stats && b.stats.Power) || 0;
                        return bPower - aPower;
                    case 'dexterity':
                        const aDex = (a.stats && a.stats.Dexterity) || 0;
                        const bDex = (b.stats && b.stats.Dexterity) || 0;
                        return bDex - aDex;
                    case 'vitality':
                        const aVit = (a.stats && a.stats.Vitality) || 0;
                        const bVit = (b.stats && b.stats.Vitality) || 0;
                        return bVit - aVit;
                    case 'tier':
                        return (b.tier || 0) - (a.tier || 0);
                    case 'rarity':
                        const rarityOrder = { 'common': 1, 'uncommon': 2, 'rare': 3, 'epic': 4, 'legendary': 5, 'mythic': 6 };
                        return (rarityOrder[b.rarity] || 0) - (rarityOrder[a.rarity] || 0);
                    case 'name':
                    default:
                        return (a.name || '').localeCompare(b.name || '');
                }
            });
            
            filteredItems.forEach(item => {
                const itemElement = document.createElement('div');
                itemElement.className = 'item-slot';
                
                let statsDisplay = '';
                // Show attributes (Power, Dexterity, Vitality)
                const attributes = [];
                if (item.stats && item.stats.Power) attributes.push(`Power: +${item.stats.Power}`);
                if (item.stats && item.stats.Dexterity) attributes.push(`Dexterity: +${item.stats.Dexterity}`);
                if (item.stats && item.stats.Vitality) attributes.push(`Vitality: +${item.stats.Vitality}`);
                if (attributes.length > 0) {
                    statsDisplay += '<span style="color: #8b4513; font-weight: bold;">Attributes:</span> ' + attributes.join(', ');
                }
                
                // Show other stats (if any)
                if (item.stats) {
                    const otherStats = Object.entries(item.stats)
                        .filter(([stat]) => !['Power', 'Dexterity', 'Vitality'].includes(stat))
                        .map(([stat, value]) => `${stat}: +${value}`);
                    if (otherStats.length > 0) {
                        if (statsDisplay) statsDisplay += '<br>';
                        statsDisplay += otherStats.join(', ');
                    }
                }
                
                // Show skills
                if (item.skills && Object.keys(item.skills).length > 0) {
                    if (statsDisplay) statsDisplay += '<br>';
                    statsDisplay += '<span style="color: #8b4513; font-weight: bold;">Skills:</span> ' + Object.entries(item.skills).map(([skill, value]) => `${skill}: +${value}`).join(', ');
                }
                if (item.levelRequirement) {
                    if (statsDisplay) statsDisplay += '<br>';
                    const levelColor = player && player.level >= item.levelRequirement ? '#48bb78' : '#e53e3e';
                    statsDisplay += `<span style="color: ${levelColor};">Level ${item.levelRequirement} Required</span>`;
                }
                
                const canEquip = !item.levelRequirement || (player && player.level >= item.levelRequirement);
                itemElement.innerHTML = `
                    <div class="item-name">${item.name}</div>
                    <div class="item-stats">
                        ${statsDisplay}
                    </div>
                    <button class="btn btn-secondary" onclick="equipItem(${item.id})" ${!canEquip ? 'disabled' : ''}>Equip</button>
                `;
                grid.appendChild(itemElement);
            });
            
            if (gameData.inventory.length === 0) {
                grid.innerHTML = '<p>No items in inventory.</p>';
            }
        }

        // Map and location management
        function enterLocation(locationId) {
            console.log("enterLocation called with:", locationId);
            console.log("gameData.locations:", gameData.locations);
            
            if (!player) {
                alert("Please create a character first!");
                return;
            }
            
            const location = gameData.locations[locationId];
            console.log("Found location:", location);
            
            if (!location) {
                alert("Location not found! Please try again.");
                console.error("Location not found for ID:", locationId);
                return;
            }
            
            currentLocation = locationId;
            
            // Track zone exploration for achievements
            const zoneKey = `zone_${locationId}`;
            if (!gameData.achievements.progress[zoneKey]) {
                gameData.achievements.progress[zoneKey] = true;
                updateAchievementProgress('zonesExplored');
            }
            
            // Ask if they want to start idle combat
            const confirmMessage = `Entering ${location.name}!\n\nThis area contains ${location.enemies.join(' and ')}.\n\nStart idle combat? Your character will automatically battle for up to 24 hours, and you'll receive progress when you return to the game.`;
            
            if (confirm(confirmMessage)) {
                startIdleCombat(locationId);
                showScreen('combat');
            }
        }

        // Inventory management
        function updateInventoryDisplay() {
            const grid = document.getElementById('inventory-grid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            if (gameData.inventory.length === 0) {
                grid.innerHTML = '<p>No items in inventory.</p>';
                return;
            }
            
            gameData.inventory.forEach(item => {
                const itemElement = document.createElement('div');
                itemElement.className = 'item-slot';
                
                const enhancementLevel = item.enhancementLevel || 0;
                const enhancementText = enhancementLevel > 0 ? ` (+${enhancementLevel})` : '';
                
                itemElement.innerHTML = `
                    <div class="item-name">${item.name}${enhancementText}</div>
                    <div class="item-stats">
                        ${Object.entries(item.stats).map(([stat, value]) => `${stat}: +${value}`).join(', ')}
                    </div>
                    <div class="item-actions">
                        <button class="btn btn-secondary" onclick="equipItem(${item.id})">Equip</button>
                        <button class="btn btn-primary" onclick="enhanceItem(${JSON.stringify(item).replace(/"/g, '&quot;')})">Enhance</button>
                        <button class="btn btn-danger" onclick="salvageItem(${JSON.stringify(item).replace(/"/g, '&quot;')})">Salvage</button>
                    </div>
                `;
                grid.appendChild(itemElement);
            });
        }

    function equipItem(itemId) {
        const item = gameData.inventory.find(i => i.id === itemId);
        if (!item) return;
        
        // Check skill requirements
        if (item.skillRequirements) {
            const totalSkills = calculateTotalSkills();
            const missingRequirements = [];
            
            Object.keys(item.skillRequirements).forEach(skill => {
                const required = item.skillRequirements[skill];
                const current = totalSkills[skill] || 0;
                if (current < required) {
                    missingRequirements.push(`${skill}: ${current}/${required}`);
                }
            });
            
            if (missingRequirements.length > 0) {
                alert(`You don't meet the skill requirements for this item:\n${missingRequirements.join('\n')}`);
                return;
            }
        }
            
            // Determine slot based on item slot property or fallback logic
            let slot = null;
            let oldItem = null;
            
            // Use the slot property if available
            if (item.slot) {
                if (item.slot === 'ring') {
                    // Prompt user to select ring slot
                    const ringSlots = [
                        { key: 'ring1', name: 'Ring Slot 1', item: gameData.equipment.ring1 },
                        { key: 'ring2', name: 'Ring Slot 2', item: gameData.equipment.ring2 },
                        { key: 'ring3', name: 'Ring Slot 3', item: gameData.equipment.ring3 },
                        { key: 'ring4', name: 'Ring Slot 4', item: gameData.equipment.ring4 }
                    ];
                    
                    let slotChoice = promptRingSlot(ringSlots, item);
                    if (slotChoice === null) {
                        return; // User cancelled
                    }
                    slot = slotChoice;
                } else if (item.slot === 'trinket') {
                    // Find an empty trinket slot
                    if (!gameData.equipment.trinket1) {
                        slot = 'trinket1';
                    } else if (!gameData.equipment.trinket2) {
                        slot = 'trinket2';
                    } else {
                        slot = 'trinket1'; // Replace first trinket if both slots full
                    }
                } else {
                    slot = item.slot;
                }
            } else {
                // Fallback to old logic if no slot property
                if (item.type === 'weapon') {
                    slot = 'mainhand';
                } else if (item.type === 'armor') {
                    const name = item.name.toLowerCase();
                    if (name.includes('helmet') || name.includes('hood') || name.includes('cap')) {
                        slot = 'helmet';
                    } else if (name.includes('shoulder') || name.includes('mantle')) {
                        slot = 'shoulders';
                    } else if (name.includes('chest') || name.includes('robe') || name.includes('armor')) {
                        slot = 'chest';
                    } else if (name.includes('bracer') || name.includes('bracers')) {
                        slot = 'bracers';
                    } else if (name.includes('glove') || name.includes('gauntlet')) {
                        slot = 'gloves';
                    } else if (name.includes('pant') || name.includes('leg')) {
                        slot = 'pants';
                    } else if (name.includes('boot') || name.includes('shoe')) {
                        slot = 'boots';
                    } else {
                        slot = 'chest'; // Default to chest for armor
                    }
                } else if (item.type === 'accessory') {
                    const name = item.name.toLowerCase();
                    if (name.includes('ring')) {
                        slot = 'ring1';
                    } else if (name.includes('necklace') || name.includes('amulet')) {
                        slot = 'necklace';
                    } else if (name.includes('cloak') || name.includes('cape')) {
                        slot = 'cape';
                    } else if (name.includes('belt')) {
                        slot = 'belt';
                    } else {
                        slot = 'trinket1';
                    }
                }
            }
            
            if (!slot) {
                alert("Cannot determine equipment slot for this item!");
                return;
            }
            
            // Store the currently equipped item to put back in inventory
            if (gameData.equipment[slot]) {
                oldItem = gameData.equipment[slot];
            }
            
            // Equip the new item
            gameData.equipment[slot] = item;
            
            // Remove the new item from inventory
            gameData.inventory = gameData.inventory.filter(i => i.id !== itemId);
            
            // Put the old item back in inventory if there was one
            if (oldItem) {
                gameData.inventory.push(oldItem);
            }
            
            // Recalculate health if Vitality changed (from equipment)
            recalculateHealth();
            
            updateCharacterDisplay();
            updateInventoryDisplay();
            saveGameData();
            alert(`Equipped ${item.name} in ${slot}!`);
        }

        // Shop and Vendor System
        let currentVendor = null;
        let currentShopTab = 'buy';

        function updateCurrencyDisplay() {
            const gold = gameData.currency.gold;
            document.getElementById('char-gold').textContent = gold;
            document.getElementById('main-gold').textContent = gold;
            document.getElementById('shops-gold').textContent = gold;
            if (document.getElementById('vendor-player-gold')) {
                document.getElementById('vendor-player-gold').textContent = gold;
            }
        }

        function updateShopsDisplay() {
            updateCurrencyDisplay();
            
            // Update reputation displays
            document.getElementById('martial-rep').textContent = gameData.vendors.martial.reputation;
            document.getElementById('magical-rep').textContent = gameData.vendors.magical.reputation;
            document.getElementById('jewelry-rep').textContent = gameData.vendors.jewelry.reputation;
            
            // Check if shops need inventory rotation
            rotateVendorInventories();
        }

        function rotateVendorInventories() {
            const rotationInterval = 12 * 60 * 60 * 1000; // 12 hours
            const now = Date.now();
            
            Object.keys(gameData.vendors).forEach(vendorType => {
                const vendor = gameData.vendors[vendorType];
                if (now - vendor.lastRotation > rotationInterval) {
                    generateVendorInventory(vendorType);
                    vendor.lastRotation = now;
                }
            });
        }

        function generateVendorInventory(vendorType) {
            const vendor = gameData.vendors[vendorType];
            const items = sampleItems.filter(item => item.category === vendorType);
            
            // Generate inventory based on reputation
            const reputation = vendor.reputation;
            let maxItems = 3 + Math.floor(reputation / 100); // More items with higher reputation
            maxItems = Math.min(maxItems, items.length);
            
            const inventory = [];
            for (let i = 0; i < maxItems; i++) {
                const item = items[Math.floor(Math.random() * items.length)];
                const inventoryItem = {
                    ...item,
                    price: Math.floor(item.value * (1 + Math.random() * 0.5)), // Random price variation
                    id: Date.now() + i // Unique ID for shop items
                };
                inventory.push(inventoryItem);
            }
            
            vendor.inventory = inventory;
            generateVendorQuests(vendorType);
        }

        function generateVendorQuests(vendorType) {
            const vendor = gameData.vendors[vendorType];
            const quests = [];
            
            // Check if enough time has passed since last quest completion (1-2 hour cooldown)
            const now = Date.now();
            const lastQuestTime = vendor.lastQuestCompletion || 0;
            const cooldownTime = (1 + Math.random()) * 60 * 60 * 1000; // 1-2 hours in milliseconds
            
            if (now - lastQuestTime < cooldownTime) {
                // Still in cooldown, don't generate new quests
                return;
            }
            
            // Generate 1-2 quests based on reputation
            const questCount = 1 + Math.floor(vendor.reputation / 200);
            
            for (let i = 0; i < questCount; i++) {
                const items = sampleItems.filter(item => item.category === vendorType);
                const targetItem = items[Math.floor(Math.random() * items.length)];
                const quantity = 2 + Math.floor(Math.random() * 3); // 2-4 items needed
                
                quests.push({
                    id: Date.now() + i,
                    type: 'collect',
                    targetItem: targetItem.name,
                    targetCategory: vendorType,
                    quantity: quantity,
                    reward: quantity * targetItem.value * 1.5, // 1.5x item value as gold reward
                    reputationReward: 25 + quantity * 5,
                    description: `Bring me ${quantity} ${targetItem.name}s for ${quantity * targetItem.value * 1.5} gold and reputation.`,
                    completed: false,
                    createdAt: now
                });
            }
            
            vendor.quests = quests;
        }

        function showVendorShop(vendorType) {
            currentVendor = vendorType;
            showScreen('vendor-shop');
            
            const vendor = gameData.vendors[vendorType];
            document.getElementById('vendor-title').textContent = vendor.name + "'s Shop";
            document.getElementById('vendor-description').textContent = getVendorDescription(vendorType);
            document.getElementById('vendor-name').textContent = vendor.name;
            document.getElementById('vendor-reputation').textContent = vendor.reputation;
            
            updateCurrencyDisplay();
            switchShopTab('buy');
        }

        function getVendorDescription(vendorType) {
            const descriptions = {
                martial: "Specializing in weapons and armor for warriors and fighters.",
                magical: "Offering enchanted weapons and robes for mages and spellcasters.",
                jewelry: "Crafting fine accessories and jewelry with magical properties."
            };
            return descriptions[vendorType] || "A specialized merchant.";
        }

        function switchShopTab(tab) {
            currentShopTab = tab;
            
            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[onclick="switchShopTab('${tab}')"]`).classList.add('active');
            
            // Update tab content
            document.querySelectorAll('.shop-tab').forEach(tab => tab.classList.remove('active'));
            document.getElementById(`${tab}-tab`).classList.add('active');
            
            // Update content based on tab
            switch(tab) {
                case 'buy':
                    updateVendorInventory();
                    break;
                case 'sell':
                    updatePlayerSellItems();
                    break;
                case 'quests':
                    updateVendorQuests();
                    break;
            }
        }

        function updateVendorInventory() {
            const grid = document.getElementById('vendor-inventory');
            const vendor = gameData.vendors[currentVendor];
            
            if (!vendor.inventory || vendor.inventory.length === 0) {
                generateVendorInventory(currentVendor);
            }
            
            grid.innerHTML = '';
                vendor.inventory.forEach(item => {
                    const itemElement = document.createElement('div');
                    itemElement.className = 'item-card';
                    itemElement.title = generateItemTooltip(item);
                    
                    const displayName = generateItemDisplayName(item);
                    
                    itemElement.innerHTML = `
                        <div class="item-name">${displayName}</div>
                        <div class="item-stats">
                            <span style="color: #d4af37;">${item.rarity.toUpperCase()}</span>
                        </div>
                        <div class="item-price">${item.price} gold</div>
                        <button class="btn btn-primary" onclick="buyItem('${item.id}')" ${gameData.currency.gold < item.price ? 'disabled' : ''}>Buy</button>
                    `;
                    grid.appendChild(itemElement);
                });
        }

        function updatePlayerSellItems() {
            const grid = document.getElementById('player-sell-items');
            const vendorType = currentVendor;
            
            // Filter items based on vendor type - more flexible matching
            const sellableItems = gameData.inventory.filter(item => {
                // Check if item has the expected category field
                if (!item.category) return false;
                
                if (vendorType === 'martial') {
                    // Martial vendor accepts weapons, armor, and martial category items
                    return item.category === 'martial' || 
                           (item.type === 'weapon' && ['martial', 'weapon'].includes(item.category)) ||
                           (item.type === 'armor' && ['martial', 'armor'].includes(item.category));
                }
                if (vendorType === 'magical') {
                    // Magical vendor accepts weapons, armor, and magical category items
                    return item.category === 'magical' || 
                           (item.type === 'weapon' && ['magical', 'weapon'].includes(item.category)) ||
                           (item.type === 'armor' && ['magical', 'armor'].includes(item.category));
                }
                if (vendorType === 'jewelry') {
                    // Jewelry vendor accepts accessories and jewelry category items
                    return item.category === 'jewelry' || item.type === 'accessory';
                }
                return false;
            });
            
            grid.innerHTML = '';
            if (sellableItems.length === 0) {
                grid.innerHTML = '<p>No items to sell to this vendor.</p>';
                return;
            }
            
                sellableItems.forEach(item => {
                    const sellPrice = Math.floor(item.value * 0.1); // 10% of item value
                    const itemElement = document.createElement('div');
                    itemElement.className = 'item-card';
                    itemElement.title = generateItemTooltip(item);
                    
                    const displayName = generateItemDisplayName(item);
                    
                    itemElement.innerHTML = `
                        <div class="item-name">${displayName}</div>
                        <div class="item-stats">
                            <span style="color: #d4af37;">${item.rarity.toUpperCase()}</span>
                        </div>
                        <div class="item-price">${sellPrice} gold</div>
                        <button class="btn btn-secondary" onclick="sellItem('${item.id}')">Sell</button>
                    `;
                    grid.appendChild(itemElement);
                });
        }

        function updateVendorQuests() {
            const container = document.getElementById('vendor-quests');
            const vendor = gameData.vendors[currentVendor];
            
            container.innerHTML = '';
            if (!vendor.quests || vendor.quests.length === 0) {
                container.innerHTML = '<p>No quests available at this time.</p>';
                return;
            }
            
            vendor.quests.forEach(quest => {
                const questElement = document.createElement('div');
                questElement.className = 'quest-item';
                questElement.innerHTML = `
                    <h4>${quest.type === 'collect' ? 'Collection Quest' : 'Quest'}</h4>
                    <p>${quest.description}</p>
                    <p><strong>Reward:</strong> ${quest.reward} gold, ${quest.reputationReward} reputation</p>
                    <button class="btn btn-primary" onclick="completeQuest('${quest.id}')" ${quest.completed ? 'disabled' : ''}>${quest.completed ? 'Completed' : 'Complete'}</button>
                `;
                container.appendChild(questElement);
            });
        }

        function buyItem(itemId) {
            const vendor = gameData.vendors[currentVendor];
            const item = vendor.inventory.find(i => i.id == itemId);
            
            if (!item || gameData.currency.gold < item.price) {
                return;
            }
            
            gameData.currency.gold -= item.price;
            gameData.inventory.push(item);
            
            updateCurrencyDisplay();
            updateVendorInventory();
            updateInventoryDisplay();
            saveGameData();
            
            alert(`Purchased ${item.name} for ${item.price} gold!`);
        }

        function sellItem(itemId) {
            const item = gameData.inventory.find(i => i.id == itemId);
            if (!item) {
                console.error("Item not found:", itemId);
                return;
            }
            
            // Check if vendor accepts this item type - flexible matching
            const vendorType = currentVendor;
            let canSell = false;
            
            if (vendorType === 'martial') {
                canSell = item.category === 'martial' || 
                         (item.type === 'weapon' && ['martial', 'weapon'].includes(item.category)) ||
                         (item.type === 'armor' && ['martial', 'armor'].includes(item.category));
            }
            if (vendorType === 'magical') {
                canSell = item.category === 'magical' || 
                         (item.type === 'weapon' && ['magical', 'weapon'].includes(item.category)) ||
                         (item.type === 'armor' && ['magical', 'armor'].includes(item.category));
            }
            if (vendorType === 'jewelry') {
                canSell = item.category === 'jewelry' || item.type === 'accessory';
            }
            
            if (!canSell) {
                alert("This vendor doesn't buy this type of item!");
                return;
            }
            
            // Calculate sell price (10% of buy price - much lower than buying)
            const sellPrice = Math.floor(item.value * 0.1);
            
            gameData.currency.gold += sellPrice;
            gameData.inventory = gameData.inventory.filter(i => i.id != itemId);
            
            updateCurrencyDisplay();
            updatePlayerSellItems();
            updateInventoryDisplay();
            saveGameData();
            
            alert(`Sold ${item.name} for ${sellPrice} gold!`);
        }
        
        function sellAllItems() {
            const vendorType = currentVendor;
            let itemsToSell = [];
            let totalGold = 0;
            
            console.log("Sell all items called for vendor:", vendorType);
            console.log("Current inventory:", gameData.inventory);
            
            // Find all items this vendor will buy
            for (let i = gameData.inventory.length - 1; i >= 0; i--) {
                const item = gameData.inventory[i];
                let canSell = false;
                
                console.log("Checking item:", item.name, "category:", item.category);
                
                if (vendorType === 'martial') {
                    canSell = item.category === 'martial' || 
                             (item.type === 'weapon' && ['martial', 'weapon'].includes(item.category)) ||
                             (item.type === 'armor' && ['martial', 'armor'].includes(item.category));
                }
                if (vendorType === 'magical') {
                    canSell = item.category === 'magical' || 
                             (item.type === 'weapon' && ['magical', 'weapon'].includes(item.category)) ||
                             (item.type === 'armor' && ['magical', 'armor'].includes(item.category));
                }
                if (vendorType === 'jewelry') {
                    canSell = item.category === 'jewelry' || item.type === 'accessory';
                }
                
                console.log("Can sell:", canSell);
                
                if (canSell) {
                    totalGold += Math.floor(item.value * 0.1);
                    itemsToSell.push(item.name);
                    gameData.inventory.splice(i, 1);
                }
            }
            
            if (itemsToSell.length > 0) {
                gameData.currency.gold += totalGold;
                updateCurrencyDisplay();
                updatePlayerSellItems();
                updateInventoryDisplay();
                saveGameData();
                alert(`Sold ${itemsToSell.length} items for ${totalGold} gold!`);
            } else {
                alert("No items to sell to this vendor.");
            }
        }

        function completeQuest(questId) {
            const vendor = gameData.vendors[currentVendor];
            const quest = vendor.quests.find(q => q.id == questId);
            
            if (!quest || quest.completed) return;
            
            // Check if player has required items
            const requiredItems = gameData.inventory.filter(item => 
                item.name === quest.targetItem && item.category === quest.targetCategory
            );
            
            if (requiredItems.length < quest.quantity) {
                alert(`You need ${quest.quantity} ${quest.targetItem}s to complete this quest.`);
                return;
            }
            
            // Remove items and give rewards
            for (let i = 0; i < quest.quantity; i++) {
                const itemIndex = gameData.inventory.findIndex(item => 
                    item.name === quest.targetItem && item.category === quest.targetCategory
                );
                if (itemIndex !== -1) {
                    gameData.inventory.splice(itemIndex, 1);
                }
            }
            
            gameData.currency.gold += quest.reward;
            vendor.reputation += quest.reputationReward;
            quest.completed = true;
            vendor.lastQuestCompletion = Date.now(); // Set cooldown timer
            
            updateCurrencyDisplay();
            updateVendorQuests();
            updateInventoryDisplay();
            saveGameData();
            
            alert(`Quest completed! Gained ${quest.reward} gold and ${quest.reputationReward} reputation!`);
        }

        // Combat system (simplified for player version)
        function startNewCombat() {
            if (!player || !currentLocation) return;
            
            const location = gameData.locations[currentLocation];
            if (!location) {
                console.error("Location not found:", currentLocation);
                return;
            }
            
            const enemyName = location.enemies[Math.floor(Math.random() * location.enemies.length)];
            
            // Start combat with maximum HP
            recalculateHealth(); // Ensure maxHp is up to date
            combatState = {
                player: {
                    hp: Math.round(player.maxHp * 10) / 10, // Start with maximum HP, rounded to nearest tenth
                    maxHp: Math.round(player.maxHp * 10) / 10,
                    power: calculateTotalStats().Power,
                    defending: false
                },
                enemy: {
                    name: enemyName,
                    hp: location.enemyStats.hp,
                    maxHp: location.enemyStats.hp,
                    power: location.enemyStats.power,
                    defending: false
                },
                turn: 'player',
                turnCount: 0,
                lastDamageDealt: 0,
                stalemateThreshold: 10 // Turns without significant damage
            };
            
            // Reset battle turn counter
            battleTurnCount = 0;
            
            // Initialize combat log for this combat instance
            combatState.log = [];
            combatState.location = currentLocation;
            
            // Clear and initialize the combat log display
            initializeCombatLog();
            
            document.getElementById('player-name').textContent = player.name;
            document.getElementById('enemy-name').textContent = enemyName;
            updateCombatDisplay();
            addCombatLog(`Encountered ${enemyName} in ${location.name}!`);
            
            // Start automatic combat after a brief delay
            setTimeout(() => {
                automaticPlayerTurn();
            }, 1000);
        }

        // Automatic combat AI
        function automaticPlayerTurn() {
            if (!combatState) {
                console.warn('automaticPlayerTurn called but combatState is null');
                return;
            }
            
            if (combatState.turn !== 'player') {
                console.warn(`automaticPlayerTurn called but turn is ${combatState.turn}, expected 'player'`);
                return;
            }
            
            // Increment turn counter
            combatState.turnCount++;
            battleTurnCount++;
            
            // Update turn counter display
            const turnCounterEl = document.getElementById('turn-counter');
            if (turnCounterEl) {
                turnCounterEl.textContent = `Turn ${battleTurnCount}/${maxBattleTurns}`;
            }
            
            // Check for stalemate conditions
            if (checkForStalemate()) {
                resolveStalemate();
                return;
            }
            
            // AI decision making - only attack
            let action = 'attack'; // Always attack
            
            // Execute the chosen action
            switch(action) {
                case 'attack':
                    // Calculate attack rating vs enemy defense
                    const combatStats = calculateCombatStats();
                    const attackRoll = Math.random() * 100;
                    const hitChance = Math.min(95, Math.max(5, 50 + (combatStats.attackRating - 50) * 0.5));
                    
                    if (attackRoll <= hitChance) {
                        let damage = Math.max(1, combatState.player.power - (combatState.enemy.defending ? 10 : 0));
                        
                        // Check for critical hit
                        if (Math.random() * 100 <= combatStats.critChance) {
                            damage *= 2;
                            addCombatLog(`Critical hit! Player attacks for ${damage.toFixed(1)} damage!`);
                        } else {
                            addCombatLog(`Player attacks for ${damage.toFixed(1)} damage!`);
                        }
                        
                        combatState.enemy.hp = Math.max(0, combatState.enemy.hp - damage);
                    } else {
                        addCombatLog(`Player's attack misses!`);
                    }
                    
                    if (combatState.enemy.hp <= 0) {
                        addCombatLog("Enemy defeated! Victory!");
                        if (combatState.isMapCombat) {
                            handleMapCombatVictory();
                        } else {
                            awardVictory();
                        }
                        return;
                    }
                    break;
                    
            }
            
            // Apply First Aid healing at end of player turn
            const combatStatsAfterAction = calculateCombatStats();
            if (combatStatsAfterAction.firstAidValue > 0) {
                const firstAidHealing = Math.round(combatStatsAfterAction.firstAidValue * 10) / 10;
                if (firstAidHealing > 0) {
                    combatState.player.hp = Math.round((Math.min(combatState.player.maxHp, combatState.player.hp + firstAidHealing)) * 10) / 10;
                    addCombatLog(`First Aid restores ${firstAidHealing.toFixed(1)} HP!`);
                }
            }
            
            // Switch to enemy turn before calling enemyTurn
            combatState.turn = 'enemy';
            combatState.enemy.defending = false;
            updateCombatDisplay();
            
            // Call enemy turn after a delay
            setTimeout(enemyTurn, 1500); // Slightly longer delay for better readability
        }

        function enemyTurn() {
            if (!combatState) {
                console.warn('enemyTurn called but combatState is null');
                return;
            }
            
            if (combatState.turn !== 'enemy') {
                console.warn(`enemyTurn called but turn is ${combatState.turn}, expected 'enemy'`);
                return;
            }
            
            const combatStats = calculateCombatStats();
            let damage = Math.max(1, combatState.enemy.power - (combatState.player.defending ? 15 : 0));
            
            // Check for dodge
            if (Math.random() * 100 <= combatStats.dodgeChance) {
                addCombatLog(`Player dodges the enemy attack!`);
            } else {
                // Check for block
                if (Math.random() * 100 <= combatStats.blockChance) {
                    damage = Math.floor(damage * 0.5);
                    addCombatLog(`Player blocks! Enemy attacks for ${damage.toFixed(1)} damage (reduced)!`);
                } else if (Math.random() * 100 <= combatStats.parryChance) {
                    // Parry reduces damage and reflects some back
                    const reflectedDamage = Math.floor(damage * 0.3);
                    damage = Math.floor(damage * 0.7);
                    combatState.enemy.hp = Math.max(0, combatState.enemy.hp - reflectedDamage);
                    addCombatLog(`Player parries! Enemy attacks for ${damage.toFixed(1)} damage, reflects ${reflectedDamage} back!`);
                } else {
                    addCombatLog(`Enemy attacks for ${damage.toFixed(1)} damage!`);
                }
                
                // Apply Defense skill reduction (reduces physical damage)
                if (combatStats.defenseValue > 0) {
                    damage = Math.max(1, damage - combatStats.defenseValue);
                }
                
                // Apply armor reduction
                damage = Math.max(1, damage - combatStats.armor);
                combatState.player.hp = Math.round((Math.max(0, combatState.player.hp - damage)) * 10) / 10;
            }
            
            if (combatState.player.hp <= 0) {
                addCombatLog("Player defeated! Applying death penalty...");
                
                if (combatState.isMapCombat) {
                    handleMapCombatDefeat();
                    return;
                }
                
                // Death penalty: lose some gold and experience
                const goldLoss = Math.floor(gameData.currency.gold * 0.1); // Lose 10% of gold
                const expLoss = Math.floor(player.experience * 0.05); // Lose 5% of experience
                
                gameData.currency.gold = Math.max(0, gameData.currency.gold - goldLoss);
                player.experience = Math.max(0, player.experience - expLoss);
                
                // Lose a random item from inventory (if any)
                if (gameData.inventory.length > 0) {
                    const randomIndex = Math.floor(Math.random() * gameData.inventory.length);
                    const lostItem = gameData.inventory.splice(randomIndex, 1)[0];
                    addCombatLog(`Lost item: ${lostItem.name}`);
                }
                
                addCombatLog(`Death penalty: Lost ${goldLoss} gold and ${expLoss} experience`);
                
                // Reset player HP to full
                player.hp = Math.round(player.maxHp * 10) / 10;
                
                combatState = null;
                updateCombatDisplay();
                updateCurrencyDisplay();
                saveGameData();
                
                // If idle combat is active, continue to next battle
                if (gameData.idleCombat.isActive) {
                    // Check if we've hit the 24-hour limit
                    const timeElapsed = Date.now() - gameData.idleCombat.startTime;
                    const maxTime = 24 * 60 * 60 * 1000; // 24 hours
                    
                    if (timeElapsed >= maxTime) {
                        addCombatLog("24-hour idle combat limit reached!");
                        stopIdleCombat();
                        return;
                    }
                    
                    // Continue to next battle after a short delay
                    setTimeout(() => {
                        if (gameData.idleCombat.isActive) {
                            startNewCombat();
                        }
                    }, 3000); // 3 second delay between battles
                }
                
                return;
            }
            
            combatState.player.defending = false;
            combatState.turn = 'player';
            updateCombatDisplay();
            
            // Automatically continue with player turn
            setTimeout(automaticPlayerTurn, 1500);
        }

        // Stalemate detection and resolution
        function checkForStalemate() {
            if (!combatState) return false;
            
            // Check for maximum turn limit
            if (battleTurnCount >= maxBattleTurns) {
                addCombatLog(`Battle has reached ${maxBattleTurns} turns! Forcing resolution...`);
                return true;
            }
            
            // Check for health stalemate (both combatants at high health for too long)
            const playerHpPercent = (combatState.player.hp / combatState.player.maxHp) * 100;
            const enemyHpPercent = (combatState.enemy.hp / combatState.enemy.maxHp) * 100;
            
            // If both are above 80% health after 20 turns, it's likely a stalemate
            if (battleTurnCount >= 20 && playerHpPercent > 80 && enemyHpPercent > 80) {
                addCombatLog("Both combatants are at high health after many turns! Forcing resolution...");
                return true;
            }
            
            // Check for healing stalemate (health not changing significantly)
            if (battleTurnCount >= 15) {
                const recentTurns = Math.min(10, battleTurnCount);
                const playerHealthChange = Math.abs(combatState.player.hp - (combatState.player.maxHp * 0.5));
                const enemyHealthChange = Math.abs(combatState.enemy.hp - (combatState.enemy.maxHp * 0.5));
                
                // If health hasn't changed much in recent turns, force resolution
                if (playerHealthChange < 5 && enemyHealthChange < 5) {
                    addCombatLog("Health levels have stabilized! Forcing resolution...");
                    return true;
                }
            }
            
            return false;
        }

        function resolveStalemate() {
            if (!combatState) return;
            
            addCombatLog("=== STALEMATE RESOLUTION ===");
            
            // Determine winner based on various factors
            const playerAdvantage = calculatePlayerAdvantage();
            const randomFactor = Math.random();
            
            if (playerAdvantage + randomFactor > 0.5) {
                // Player wins stalemate
                addCombatLog("The stalemate breaks in your favor! Victory!");
                combatState.enemy.hp = 0;
                awardVictory();
            } else {
                // Enemy wins stalemate
                addCombatLog("The stalemate breaks against you! Defeat!");
                combatState.player.hp = 0.0;
                combatState = null;
                updateCombatDisplay();
                addCombatLog("You have been defeated! Returning to map...");
                setTimeout(() => {
                    showMap();
                }, 2000);
            }
        }

        function calculatePlayerAdvantage() {
            if (!combatState) return 0;
            
            let advantage = 0;
            
            // Health advantage
            const playerHpPercent = (combatState.player.hp / combatState.player.maxHp) * 100;
            const enemyHpPercent = (combatState.enemy.hp / combatState.enemy.maxHp) * 100;
            advantage += (playerHpPercent - enemyHpPercent) / 200; // Normalize to -0.5 to 0.5
            
            // Power advantage
            const powerRatio = combatState.player.power / combatState.enemy.power;
            advantage += (powerRatio - 1) * 0.3; // Scale power difference
            
            // Turn count advantage (longer battles favor the player due to skills/equipment)
            if (battleTurnCount > 20) {
                advantage += 0.2; // Slight advantage for surviving longer
            }
            
            // Equipment advantage (if player has good equipment)
            const totalStats = calculateTotalStats();
            if (totalStats.Power > combatState.enemy.power) {
                advantage += 0.1;
            }
            
            return Math.max(-0.4, Math.min(0.4, advantage)); // Clamp between -0.4 and 0.4
        }

        function awardVictory() {
            // Award experience and potentially items
            const location = gameData.locations[currentLocation];
            if (location) {
                player.experience += 10 + (location.level || 1) * 5; // More XP for higher level zones
                
                // Check for tier progression (based on total attributes and skills)
                const oldTier = calculateCharacterTier();
                const newTier = calculateCharacterTier();
                if (newTier > oldTier) {
                    const rank = getCharacterRank(newTier);
                    addCombatLog(`Tier advancement! You are now ${rank} (Tier ${newTier})!`);
                }
                
                // Zone-specific item drops with random generation
                if (Math.random() < 0.4 && location.uniqueLoot && location.uniqueLoot.length > 0) { // 40% chance for item drops
                    const zoneBaseItems = baseItems.filter(item => 
                        item.zones && item.zones.includes(location.uniqueLoot[0])
                    );
                    
                    if (zoneBaseItems.length > 0) {
                        const randomBaseItem = zoneBaseItems[Math.floor(Math.random() * zoneBaseItems.length)];
                        const newItem = generateRandomItem(randomBaseItem);
                        gameData.inventory.push(newItem);
                        addCombatLog(`Found ${newItem.name} (${newItem.rarity}) with random bonuses!`);
                        updateAchievementProgress('itemsFound');
                    }
                    
                    // Material drops (30% chance)
                    if (Math.random() < 0.3 && location.uniqueLoot && location.uniqueLoot.length > 0) {
                        const materials = getZoneMaterials(location.uniqueLoot[0]);
                        const materialType = materials[Math.floor(Math.random() * materials.length)];
                        gameData.crafting.materials[materialType] += 1;
                        updateAchievementProgress('materialsCollected');
                        addCombatLog(`Found 1 ${materialType}!`);
                    }
                }
            } else {
                // Fallback for when location is not found
                player.experience += 10;
            }
            
            // Apply Primary Skill changes (Power, Dexterity, Vitality) based on toggle states
            let changesApplied = false;
            Object.keys(gameData.attributeToggles).forEach(attr => {
                const toggleState = gameData.attributeToggles[attr];
                if (toggleState === 'increase') {
                    // Check total attribute cap and individual cap
                    const currentTotal = Object.values(player.attributes).reduce((sum, val) => sum + val, 0);
                    const maxTotal = 300;
                    const maxPerAttribute = 150;
                    const currentAttrValue = player.attributes[attr];
                    
                    // Calculate gain using exponential scaling
                    const gain = calculateAttributeGain(0.1, currentAttrValue, gameData.prestige.level);
                    const newAttrValue = currentAttrValue + gain;
                    const newTotal = currentTotal - currentAttrValue + newAttrValue;
                    
                    // Check both individual cap (150) and total cap (300)
                    if (newAttrValue <= maxPerAttribute && newTotal <= maxTotal) {
                        player.attributes[attr] = newAttrValue;
                        addCombatLog(`Gained ${gain.toFixed(3)} ${attr} (Primary Skill) from victory!`);
                        changesApplied = true;
                    } else {
                        addCombatLog(`${attr} cannot increase further (cap reached)`);
                    }
                } else if (toggleState === 'decrease') {
                    const currentAttrValue = player.attributes[attr];
                    const loss = calculateAttributeGain(0.1, currentAttrValue, gameData.prestige.level);
                    player.attributes[attr] = Math.max(0, player.attributes[attr] - loss);
                    addCombatLog(`Lost ${loss.toFixed(3)} ${attr} (Primary Skill) from battle!`);
                    changesApplied = true;
                }
            });
            
            // Apply Secondary Skill changes based on toggle states
            Object.keys(gameData.skillToggles).forEach(skill => {
                const toggleState = gameData.skillToggles[skill];
                if (toggleState === 'increase') {
                    // Check total skill cap
                    const currentTotal = Object.values(gameData.skills).reduce((sum, val) => sum + val, 0);
                    const maxTotal = 600;
                    const currentSkillValue = gameData.skills[skill];
                    const newSkillValue = currentSkillValue + 0.1;
                    
                    // Check both individual cap (100) and total cap (600)
                    if (newSkillValue <= 100 && (currentTotal - currentSkillValue + newSkillValue) <= maxTotal) {
                        gameData.skills[skill] = newSkillValue;
                        addCombatLog(`Gained 0.1 ${skill} (Secondary Skill) from victory!`);
                        changesApplied = true;
                    } else {
                        addCombatLog(`${skill} cannot increase further (cap reached)`);
                    }
                } else if (toggleState === 'decrease') {
                    gameData.skills[skill] = Math.max(0, gameData.skills[skill] - 0.1);
                    addCombatLog(`Lost 0.1 ${skill} (Secondary Skill) from battle!`);
                    changesApplied = true;
                }
            });
            
            if (!changesApplied) {
                addCombatLog("No attribute/skill changes applied (all locked)");
            }
            
            // Apply Restoration skill healing at end of combat (percentage-based)
            const totalSkills = calculateTotalSkills();
            if (totalSkills.Restoration > 0) {
                const restorationPercentage = totalSkills.Restoration * 0.005; // 0.5% per skill point
                const restorationHealing = Math.round((player.maxHp * restorationPercentage) * 10) / 10;
                if (restorationHealing > 0) {
                    player.hp = Math.round((Math.min(player.maxHp, player.hp + restorationHealing)) * 10) / 10;
                    addCombatLog(`Restoration restores ${restorationHealing.toFixed(1)} HP (${(restorationPercentage * 100).toFixed(1)}% of max HP) after battle!`);
                }
            }
            
            // Recalculate health if vitality changed
            if (gameData.attributeToggles.Vitality !== 'lock') {
                recalculateHealth(); // Use centralized function to ensure consistency
            }
            
            // Update achievement progress
            updateAchievementProgress('battlesWon');
            updateAchievementProgress('enemiesDefeated');
            
            // Update tier achievement progress
            const currentTier = calculateCharacterTier();
            if (currentTier > gameData.achievements.progress.maxTierReached) {
                gameData.achievements.progress.maxTierReached = currentTier;
                checkAchievements();
            }
            
            // Check challenge progress
            checkChallengeProgress();
            
            // Handle procedural content completion
            if (currentLocation === 'procedural_dungeon') {
                completeDungeonFloor();
            } else if (currentLocation && currentLocation.startsWith('infinite_')) {
                completeInfiniteZone();
            }
            
            // Update idle combat progress
            if (gameData.idleCombat.isActive) {
                gameData.idleCombat.battlesCompleted++;
                gameData.idleCombat.totalMonstersDefeated++;
                
                // Check if we've hit the 24-hour limit
                const timeElapsed = Date.now() - gameData.idleCombat.startTime;
                const maxTime = 24 * 60 * 60 * 1000; // 24 hours
                
                if (timeElapsed >= maxTime) {
                    addCombatLog("24-hour idle combat limit reached!");
                    stopIdleCombat();
                    return;
                }
                
                // Continue to next battle after a short delay
                setTimeout(() => {
                    if (gameData.idleCombat.isActive) {
                        startNewCombat();
                    }
                }, 3000); // 3 second delay between battles
            }
            
            combatState = null;
            updateCombatDisplay();
            updateCharacterDisplay();
            updateInventoryDisplay();
            saveGameData();
        }

        function updateCombatDisplay() {
            if (!combatState) {
                document.getElementById('player-health').style.width = '100%';
                document.getElementById('player-hp-text').textContent = '100/100';
                document.getElementById('enemy-health').style.width = '100%';
                document.getElementById('enemy-hp-text').textContent = '80/80';
                return;
            }
            
            const playerHealthPercent = (combatState.player.hp / combatState.player.maxHp) * 100;
            const enemyHealthPercent = (combatState.enemy.hp / combatState.enemy.maxHp) * 100;
            
            document.getElementById('player-health').style.width = playerHealthPercent + '%';
            document.getElementById('player-hp-text').textContent = `${combatState.player.hp.toFixed(1)}/${combatState.player.maxHp.toFixed(1)}`;
            document.getElementById('enemy-health').style.width = enemyHealthPercent + '%';
            document.getElementById('enemy-hp-text').textContent = `${combatState.enemy.hp.toFixed(1)}/${combatState.enemy.maxHp.toFixed(1)}`;
            
            // Update turn counter display
            const turnDisplay = document.getElementById('turn-counter');
            if (turnDisplay) {
                turnDisplay.textContent = `Turn ${battleTurnCount}/${maxBattleTurns}`;
                
                // Color code based on turn count
                if (battleTurnCount >= maxBattleTurns * 0.8) {
                    turnDisplay.style.color = '#e53e3e'; // Red for high turn count
                } else if (battleTurnCount >= maxBattleTurns * 0.6) {
                    turnDisplay.style.color = '#dd6b20'; // Orange for medium-high turn count
                } else {
                    turnDisplay.style.color = '#38a169'; // Green for normal turn count
                }
            }
        }

        function addCombatLog(message) {
            const logContent = document.getElementById('log-content');
            const time = new Date().toLocaleTimeString();
            
            // If combatState exists, add to its log array for per-combat tracking
            if (combatState && combatState.log) {
                combatState.log.push({ time, message });
            }
            
            // Update display
            if (logContent) {
                logContent.innerHTML += `<div>[${time}] ${message}</div>`;
                logContent.scrollTop = logContent.scrollHeight;
            }
        }

        // Initialize combat log for new combat instance
        function initializeCombatLog() {
            const logContent = document.getElementById('log-content');
            if (logContent) {
                logContent.innerHTML = '';
            }
            if (combatState) {
                combatState.log = [];
            }
        }

        function fleeCombat() {
            if (confirm("Flee from combat? You'll return to the map.")) {
                combatState = null;
                showMap();
            }
        }

        // Main game functions
        function startNewGame() {
            showCharacter();
            // Always show character creation section if no player exists
            if (!player) {
                document.getElementById('no-character-section').style.display = 'block';
                document.getElementById('character-display-section').style.display = 'none';
                updateCharacterDisplay();
            } else {
                updateCharacterDisplay();
            }
        }

        function loadGame() {
            alert("Load Game - Coming soon! This would load a saved game from file.");
        }

        // Keyboard shortcuts
        document.addEventListener("keydown", (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case "n":
                        e.preventDefault();
                        startNewGame();
                        break;
                    case "c":
                        e.preventDefault();
                        showCharacter();
                        break;
                    case "m":
                        e.preventDefault();
                        showMap();
                        break;
                    case "i":
                        e.preventDefault();
                        showInventory();
                        break;
                }
            }
        });

        // Test function to verify JavaScript is working
        function testFunction() {
            alert("JavaScript is working!");
        }

        // Debug function to force show character creation
        function forceShowCharacterCreation() {
            document.getElementById('no-character-section').style.display = 'block';
            document.getElementById('character-display-section').style.display = 'none';
            alert("Character creation section should now be visible!");
        }

        // Reset character data function
        function resetCharacterData() {
            if (confirm("Are you sure you want to reset all character data? This cannot be undone!")) {
                // Clear all game data
                localStorage.removeItem('pandimusGameData');
                localStorage.removeItem('pandimusPlayerData');
                
                // Reset player and gameData objects
                player = null;
                gameData = {
                    player: null,
                    inventory: [],
                    equipment: {
                        mainhand: null,
                        offhand: null,
                        helmet: null,
                        chest: null,
                        legs: null,
                        boots: null,
                        ring1: null,
                        ring2: null,
                        ring3: null,
                        ring4: null,
                        necklace: null
                    },
                    currency: { gold: 100 },
                    skills: {},
                    attributeToggles: {
                        Power: 'auto',
                        Dexterity: 'auto',
                        Vitality: 'auto'
                    },
                    skillToggles: {},
                    prestige: { level: 0, points: 0 }
                };
                
                // Reset game engine
                if (window.gameEngine) {
                    window.gameEngine = null;
                }
                
                // Show character creation section
                document.getElementById('no-character-section').style.display = 'block';
                document.getElementById('character-display-section').style.display = 'none';
                
                // Clear and enable the name input
                setTimeout(() => {
                    const nameInput = document.getElementById('char-name-input');
                    if (nameInput) {
                        nameInput.value = '';
                        nameInput.disabled = false;
                        nameInput.readOnly = false;
                        nameInput.removeAttribute('disabled');
                        nameInput.removeAttribute('readonly');
                        nameInput.style.pointerEvents = 'auto';
                        nameInput.style.opacity = '1';
                        nameInput.style.background = '#fff';
                        nameInput.style.color = '#000';
                        nameInput.focus();
                        nameInput.select();
                    }
                }, 100);
                
                // Update display
                updateCharacterDisplay();
            }
        }

        // Prestige function
        function attemptPrestige() {
            if (!canPrestige()) {
                alert("You need at least 150 total attributes and 400 total skills to prestige!");
                return;
            }
            
            const totalAttributes = Object.values(player.attributes).reduce((sum, val) => sum + val, 0);
            const totalSkills = Object.values(gameData.skills).reduce((sum, val) => sum + val, 0);
            const prestigePoints = Math.floor((totalAttributes + totalSkills) / 10);
            
            if (confirm(`Prestige will reset your character but give you ${prestigePoints} prestige points and permanent bonuses. Continue?`)) {
                if (performPrestige()) {
                    alert(`Prestige successful! You gained ${prestigePoints} prestige points and permanent bonuses!`);
                    updateCharacterDisplay();
                    updateCurrencyDisplay();
                    saveGameData();
                }
            }
        }

        // Achievement system
        const achievementDefinitions = {
            firstBlood: { id: "firstBlood", name: "First Blood", description: "Defeat your first enemy", reward: "100 gold", condition: { battlesWon: 1 } },
            warrior: { id: "warrior", name: "Warrior", description: "Win 10 battles", reward: "500 gold", condition: { battlesWon: 10 } },
            veteran: { id: "veteran", name: "Veteran", description: "Win 100 battles", reward: "2000 gold", condition: { battlesWon: 100 } },
            legendary: { id: "legendary", name: "Legendary Warrior", description: "Win 1000 battles", reward: "10000 gold", condition: { battlesWon: 1000 } },
            explorer: { id: "explorer", name: "Explorer", description: "Explore 3 different zones", reward: "300 gold", condition: { zonesExplored: 3 } },
            masterExplorer: { id: "masterExplorer", name: "Master Explorer", description: "Explore all zones", reward: "5000 gold", condition: { zonesExplored: 8 } },
            collector: { id: "collector", name: "Collector", description: "Find 50 items", reward: "1000 gold", condition: { itemsFound: 50 } },
            hoarder: { id: "hoarder", name: "Hoarder", description: "Find 500 items", reward: "5000 gold", condition: { itemsFound: 500 } },
            wealthy: { id: "wealthy", name: "Wealthy", description: "Earn 10000 gold", reward: "Bonus gold multiplier", condition: { goldEarned: 10000 } },
            rich: { id: "rich", name: "Rich", description: "Earn 100000 gold", reward: "Major gold multiplier", condition: { goldEarned: 100000 } },
            novice: { id: "novice", name: "Novice", description: "Reach Tier 2", reward: "200 gold", condition: { maxTierReached: 2 } },
            adept: { id: "adept", name: "Adept", description: "Reach Tier 5", reward: "1000 gold", condition: { maxTierReached: 5 } },
            master: { id: "master", name: "Master", description: "Reach Tier 8", reward: "5000 gold", condition: { maxTierReached: 8 } },
            ascended: { id: "ascended", name: "Ascended", description: "Reach Tier 10", reward: "10000 gold", condition: { maxTierReached: 10 } },
            reborn: { id: "reborn", name: "Reborn", description: "Complete your first prestige", reward: "Prestige bonus", condition: { prestigeLevels: 1 } },
            eternal: { id: "eternal", name: "Eternal", description: "Complete 5 prestiges", reward: "Major prestige bonus", condition: { prestigeLevels: 5 } }
        };

        function checkAchievements() {
            const achievements = gameData.achievements;
            const progress = achievements.progress;
            
            Object.values(achievementDefinitions).forEach(achievement => {
                if (achievements.completed.includes(achievement.id)) return; // Already completed
                
                let completed = true;
                Object.entries(achievement.condition).forEach(([key, required]) => {
                    if (progress[key] < required) {
                        completed = false;
                    }
                });
                
                if (completed) {
                    achievements.completed.push(achievement.id);
                    awardAchievement(achievement);
                }
            });
        }

        function awardAchievement(achievement) {
            // Award the achievement reward
            if (achievement.reward.includes("gold")) {
                const goldAmount = parseInt(achievement.reward.match(/\d+/)[0]);
                gameData.currency.gold += goldAmount;
                updateCurrencyDisplay();
            }
            
            // Show achievement notification
            alert(`üèÜ Achievement Unlocked: ${achievement.name}!\n${achievement.description}\nReward: ${achievement.reward}`);
            
            // Save game data
            saveGameData();
        }

        function updateAchievementProgress(type, amount = 1) {
            if (gameData.achievements.progress[type] !== undefined) {
                gameData.achievements.progress[type] += amount;
                checkAchievements();
            }
        }

        // Crafting and Enhancement System
        const craftingRecipes = {
            // Basic weapons
            ironSword: { 
                name: "Iron Sword", 
                materials: { iron: 5, wood: 2 }, 
                goldCost: 50, 
                result: { type: "weapon", slot: "mainhand", stats: { Power: 8 }, rarity: "common", tier: 1 },
                unlockRequirement: { tier: 1 }
            },
            ironMace: { 
                name: "Iron Mace", 
                materials: { iron: 6, wood: 1 }, 
                goldCost: 55, 
                result: { type: "weapon", slot: "mainhand", stats: { Power: 9 }, rarity: "common", tier: 1 },
                unlockRequirement: { tier: 1 }
            },
            // Enhanced weapons
            steelSword: { 
                name: "Steel Sword", 
                materials: { iron: 10, crystal: 2, enhancementStone: 1 }, 
                goldCost: 200, 
                result: { type: "weapon", slot: "mainhand", stats: { Power: 15, Dexterity: 2 }, rarity: "uncommon", tier: 2 },
                unlockRequirement: { tier: 2 }
            },
            // Armor crafting
            leatherArmor: { 
                name: "Leather Armor", 
                materials: { leather: 8, wood: 3 }, 
                goldCost: 80, 
                result: { type: "armor", slot: "chest", stats: { Vitality: 6, Dexterity: 2 }, rarity: "common", tier: 1 },
                unlockRequirement: { tier: 1 }
            },
            chainMail: { 
                name: "Chain Mail", 
                materials: { iron: 15, leather: 5, enhancementStone: 2 }, 
                goldCost: 300, 
                result: { type: "armor", slot: "chest", stats: { Vitality: 12, Power: 3 }, rarity: "uncommon", tier: 2 },
                unlockRequirement: { tier: 2 }
            },
            // High-tier crafting
            dragonScaleArmor: { 
                name: "Dragon Scale Armor", 
                materials: { dragonScale: 10, voidEssence: 3, enhancementStone: 5 }, 
                goldCost: 2000, 
                result: { type: "armor", slot: "chest", stats: { Power: 20, Vitality: 18, Dexterity: 8 }, rarity: "epic", tier: 5 },
                unlockRequirement: { tier: 5 }
            },
            celestialBlade: { 
                name: "Celestial Blade", 
                materials: { celestialShard: 8, magicEssence: 5, enhancementStone: 10 }, 
                goldCost: 5000, 
                result: { type: "weapon", slot: "mainhand", stats: { Power: 35, Dexterity: 15 }, rarity: "legendary", tier: 7 },
                unlockRequirement: { tier: 7 }
            }
        };

        function canCraft(recipeId) {
            const recipe = craftingRecipes[recipeId];
            if (!recipe) return false;
            
            // Check if recipe is unlocked
            if (!gameData.crafting.unlockedRecipes.includes(recipeId)) {
                const tier = calculateCharacterTier();
                if (recipe.unlockRequirement.tier > tier) return false;
            }
            
            // Check materials
            for (const [material, amount] of Object.entries(recipe.materials)) {
                if (gameData.crafting.materials[material] < amount) return false;
            }
            
            // Check gold
            if (gameData.currency.gold < recipe.goldCost) return false;
            
            return true;
        }

        function craftItem(recipeId) {
            const recipe = craftingRecipes[recipeId];
            console.log('Attempting to craft:', recipeId, recipe);
            console.log('Current materials:', gameData.crafting.materials);
            console.log('Current gold:', gameData.currency.gold);
            
            if (!canCraft(recipeId)) {
                alert("Cannot craft this item! Check materials and gold requirements.");
                return false;
            }
            
            // Consume materials
            for (const [material, amount] of Object.entries(recipe.materials)) {
                gameData.crafting.materials[material] -= amount;
            }
            
            // Consume gold
            gameData.currency.gold -= recipe.goldCost;
            
            // Create item
            const newItem = generateRandomItem(recipe.result);
            newItem.id = Date.now() + Math.random();
            gameData.inventory.push(newItem);
            
            console.log('Created item:', newItem);
            console.log('Inventory after crafting:', gameData.inventory.length);
            
            // Unlock recipe if not already unlocked
            if (!gameData.crafting.unlockedRecipes.includes(recipeId)) {
                gameData.crafting.unlockedRecipes.push(recipeId);
            }
            
            updateInventoryDisplay();
            updateCurrencyDisplay();
            updateMaterialsDisplay();
            saveGameData();
            
            // Update crafting challenge progress
            updateAchievementProgress('itemsCrafted');
            checkChallengeProgress();
            
            alert(`Successfully crafted ${recipe.name}!`);
            return true;
        }

        function salvageItem(item) {
            if (!item) return;
            
            // Calculate salvage materials based on item tier and rarity
            const tier = item.tier || 1;
            const rarityMultiplier = {
                common: 1,
                uncommon: 1.5,
                rare: 2,
                epic: 3,
                legendary: 4,
                mythic: 5
            }[item.rarity] || 1;
            
            const baseMaterials = Math.floor(tier * rarityMultiplier);
            
            // Determine material type based on item category
            let materialType = 'iron';
            if (item.category === 'magical') materialType = 'magicEssence';
            else if (item.category === 'jewelry') materialType = 'crystal';
            else if (item.name.toLowerCase().includes('dragon')) materialType = 'dragonScale';
            else if (item.name.toLowerCase().includes('void')) materialType = 'voidEssence';
            else if (item.name.toLowerCase().includes('celestial')) materialType = 'celestialShard';
            else if (item.name.toLowerCase().includes('nightmare')) materialType = 'nightmareFragment';
            
            // Add materials
            gameData.crafting.materials[materialType] += baseMaterials;
            
            // Add enhancement stones for higher tier items
            if (tier >= 3) {
                gameData.crafting.materials.enhancementStone += Math.floor(tier / 2);
            }
            
            // Remove item from inventory
            const itemIndex = gameData.inventory.findIndex(invItem => invItem.id === item.id);
            if (itemIndex !== -1) {
                gameData.inventory.splice(itemIndex, 1);
            }
            
            updateInventoryDisplay();
            saveGameData();
            
            alert(`Salvaged ${item.name} for ${baseMaterials} ${materialType}${tier >= 3 ? ` and ${Math.floor(tier / 2)} enhancement stones` : ''}!`);
        }

        function enhanceItem(item) {
            if (!item) return false;
            
            const enhancementCost = Math.floor(item.tier * 100 * Math.pow(1.5, item.enhancementLevel || 0));
            const stonesRequired = Math.floor((item.enhancementLevel || 0) + 1);
            
            if (gameData.currency.gold < enhancementCost) {
                alert(`Not enough gold! Enhancement costs ${enhancementCost} gold.`);
                return false;
            }
            
            if (gameData.crafting.materials.enhancementStone < stonesRequired) {
                alert(`Not enough enhancement stones! Requires ${stonesRequired} stones.`);
                return false;
            }
            
            // Calculate success chance (decreases with enhancement level)
            const baseChance = 100;
            const currentLevel = item.enhancementLevel || 0;
            const successChance = Math.max(10, baseChance - (currentLevel * 15));
            
            if (Math.random() * 100 > successChance) {
                // Enhancement failed
                gameData.currency.gold -= Math.floor(enhancementCost * 0.5); // Lose half the gold
                gameData.crafting.materials.enhancementStone -= Math.floor(stonesRequired * 0.5); // Lose half the stones
                alert(`Enhancement failed! Lost ${Math.floor(enhancementCost * 0.5)} gold and ${Math.floor(stonesRequired * 0.5)} enhancement stones.`);
                updateCurrencyDisplay();
                saveGameData();
                return false;
            }
            
            // Enhancement successful
            gameData.currency.gold -= enhancementCost;
            gameData.crafting.materials.enhancementStone -= stonesRequired;
            
            // Increase enhancement level
            item.enhancementLevel = (item.enhancementLevel || 0) + 1;
            
            // Increase stats by 10% per enhancement level
            const statMultiplier = 1 + (item.enhancementLevel * 0.1);
            Object.keys(item.stats).forEach(stat => {
                item.stats[stat] = Math.floor(item.stats[stat] * statMultiplier);
            });
            
            updateInventoryDisplay();
            updateCurrencyDisplay();
            saveGameData();
            
            alert(`Enhancement successful! ${item.name} is now +${item.enhancementLevel}!`);
            return true;
        }

        function getZoneMaterials(zoneType) {
            const materialMap = {
                forest: ['wood', 'leather'],
                crystal: ['crystal', 'magicEssence'],
                ancient: ['iron', 'crystal'],
                dragon: ['dragonScale', 'enhancementStone'],
                abyssal: ['voidEssence', 'enhancementStone'],
                swamp: ['leather', 'wood'],
                desert: ['iron', 'crystal'],
                volcanic: ['iron', 'enhancementStone'],
                frozen: ['crystal', 'magicEssence'],
                nightmare: ['nightmareFragment', 'voidEssence'],
                celestial: ['celestialShard', 'magicEssence'],
                void: ['voidEssence', 'enhancementStone']
            };
            return materialMap[zoneType] || ['iron', 'wood'];
        }

        // Challenge System
        const challengeDefinitions = {
            daily: [
                { id: 'daily_battles', name: 'Daily Warrior', description: 'Win 10 battles today', reward: { gold: 500, materials: { enhancementStone: 2 } }, condition: { battlesWon: 10 } },
                { id: 'daily_exploration', name: 'Daily Explorer', description: 'Explore 2 different zones today', reward: { gold: 300, materials: { crystal: 3 } }, condition: { zonesExplored: 2 } },
                { id: 'daily_crafting', name: 'Daily Crafter', description: 'Craft 3 items today', reward: { gold: 400, materials: { iron: 5, wood: 3 } }, condition: { itemsCrafted: 3 } },
                { id: 'daily_materials', name: 'Daily Gatherer', description: 'Collect 15 materials today', reward: { gold: 350, materials: { enhancementStone: 1 } }, condition: { materialsCollected: 15 } }
            ],
            weekly: [
                { id: 'weekly_battles', name: 'Weekly Warrior', description: 'Win 100 battles this week', reward: { gold: 3000, materials: { enhancementStone: 10, dragonScale: 2 } }, condition: { battlesWon: 100 } },
                { id: 'weekly_prestige', name: 'Weekly Ascension', description: 'Complete 1 prestige this week', reward: { gold: 5000, materials: { voidEssence: 5, celestialShard: 3 } }, condition: { prestigeCompleted: 1 } },
                { id: 'weekly_items', name: 'Weekly Collector', description: 'Find 50 items this week', reward: { gold: 2500, materials: { enhancementStone: 8, magicEssence: 5 } }, condition: { itemsFound: 50 } },
                { id: 'weekly_zones', name: 'Weekly Explorer', description: 'Explore all 8 zones this week', reward: { gold: 4000, materials: { enhancementStone: 15, nightmareFragment: 3 } }, condition: { zonesExplored: 8 } }
            ]
        };

        function checkChallengeReset() {
            const now = Date.now();
            const dailyReset = 24 * 60 * 60 * 1000; // 24 hours
            const weeklyReset = 7 * 24 * 60 * 60 * 1000; // 7 days
            
            // Check daily reset
            if (now - gameData.challenges.daily.lastReset >= dailyReset) {
                gameData.challenges.daily.active = null;
                gameData.challenges.daily.completed = [];
                gameData.challenges.daily.lastReset = now;
                generateNewChallenge('daily');
            }
            
            // Check weekly reset
            if (now - gameData.challenges.weekly.lastReset >= weeklyReset) {
                gameData.challenges.weekly.active = null;
                gameData.challenges.weekly.completed = [];
                gameData.challenges.weekly.lastReset = now;
                generateNewChallenge('weekly');
            }
        }

        function generateNewChallenge(type) {
            const availableChallenges = challengeDefinitions[type].filter(challenge => 
                !gameData.challenges[type].completed.includes(challenge.id)
            );
            
            if (availableChallenges.length > 0) {
                const randomChallenge = availableChallenges[Math.floor(Math.random() * availableChallenges.length)];
                gameData.challenges[type].active = randomChallenge;
            }
        }

        function checkChallengeProgress() {
            checkChallengeReset();
            
            ['daily', 'weekly'].forEach(type => {
                const challenge = gameData.challenges[type].active;
                if (!challenge) {
                    generateNewChallenge(type);
                    return;
                }
                
                let completed = true;
                Object.entries(challenge.condition).forEach(([key, required]) => {
                    const progress = gameData.achievements.progress[key] || 0;
                    if (progress < required) {
                        completed = false;
                    }
                });
                
                if (completed) {
                    completeChallenge(type, challenge);
                }
            });
        }

        function completeChallenge(type, challenge) {
            // Award rewards
            if (challenge.reward.gold) {
                gameData.currency.gold += challenge.reward.gold;
            }
            
            if (challenge.reward.materials) {
                Object.entries(challenge.reward.materials).forEach(([material, amount]) => {
                    gameData.crafting.materials[material] += amount;
                });
            }
            
            // Mark as completed
            gameData.challenges[type].completed.push(challenge.id);
            gameData.challenges[type].streak++;
            gameData.challenges[type].active = null;
            
            // Generate new challenge
            generateNewChallenge(type);
            
            // Show notification
            alert(`üèÜ Challenge Completed: ${challenge.name}!\n${challenge.description}\nReward: ${challenge.reward.gold} gold${challenge.reward.materials ? ' + materials' : ''}`);
            
            updateCurrencyDisplay();
            saveGameData();
        }

        function getChallengeProgress(type) {
            const challenge = gameData.challenges[type].active;
            if (!challenge) return null;
            
            const progress = {};
            Object.entries(challenge.condition).forEach(([key, required]) => {
                const current = gameData.achievements.progress[key] || 0;
                progress[key] = { current, required };
            });
            
            return { challenge, progress };
        }

        // Seasonal Content System
        const seasonalEvents = {
            dragonHunt: {
                id: 'dragonHunt',
                name: 'Dragon Hunt Festival',
                description: 'Special dragons appear in all zones with increased rewards!',
                duration: 7 * 24 * 60 * 60 * 1000, // 7 days
                rewards: {
                    dragonScale: 2,
                    enhancementStone: 3,
                    seasonalCurrency: 100
                },
                modifiers: {
                    dropRateMultiplier: 1.5,
                    experienceMultiplier: 1.3,
                    goldMultiplier: 1.2
                },
                unlockRequirement: { tier: 3 }
            },
            crystalHarvest: {
                id: 'crystalHarvest',
                name: 'Crystal Harvest',
                description: 'Crystal formations appear throughout the world with rare materials!',
                duration: 5 * 24 * 60 * 60 * 1000, // 5 days
                rewards: {
                    crystal: 5,
                    magicEssence: 3,
                    seasonalCurrency: 75
                },
                modifiers: {
                    materialDropRate: 2.0,
                    enhancementStoneDropRate: 1.5
                },
                unlockRequirement: { tier: 2 }
            },
            voidInvasion: {
                id: 'voidInvasion',
                name: 'Void Invasion',
                description: 'Void creatures invade normal zones with legendary rewards!',
                duration: 10 * 24 * 60 * 60 * 1000, // 10 days
                rewards: {
                    voidEssence: 3,
                    nightmareFragment: 2,
                    seasonalCurrency: 200
                },
                modifiers: {
                    legendaryDropRate: 2.0,
                    prestigePointMultiplier: 1.5
                },
                unlockRequirement: { tier: 5 }
            },
            celestialBlessing: {
                id: 'celestialBlessing',
                name: 'Celestial Blessing',
                description: 'Divine beings bless adventurers with enhanced progression!',
                duration: 14 * 24 * 60 * 60 * 1000, // 14 days
                rewards: {
                    celestialShard: 2,
                    seasonalCurrency: 150
                },
                modifiers: {
                    attributeGainMultiplier: 1.5,
                    skillGainMultiplier: 1.5,
                    challengeRewardMultiplier: 1.3
                },
                unlockRequirement: { tier: 4 }
            }
        };

        function checkSeasonalEvents() {
            const now = Date.now();
            const currentEvent = gameData.seasonal.currentEvent;
            
            // Check if current event has ended
            if (currentEvent && now >= gameData.seasonal.eventEndTime) {
                endSeasonalEvent();
            }
            
            // Check for new events (simplified - in real game, this would be server-controlled)
            if (!currentEvent) {
                const availableEvents = Object.values(seasonalEvents).filter(event => {
                    const tier = calculateCharacterTier();
                    return tier >= event.unlockRequirement.tier && 
                           !gameData.seasonal.unlockedEvents.includes(event.id);
                });
                
                if (availableEvents.length > 0) {
                    const randomEvent = availableEvents[Math.floor(Math.random() * availableEvents.length)];
                    startSeasonalEvent(randomEvent);
                }
            }
        }

        function startSeasonalEvent(event) {
            gameData.seasonal.currentEvent = event;
            gameData.seasonal.eventStartTime = Date.now();
            gameData.seasonal.eventEndTime = Date.now() + event.duration;
            gameData.seasonal.eventProgress = {};
            
            alert(`üéâ Seasonal Event Started: ${event.name}!\n${event.description}\nDuration: ${Math.floor(event.duration / (24 * 60 * 60 * 1000))} days`);
            saveGameData();
        }

        function endSeasonalEvent() {
            const event = gameData.seasonal.currentEvent;
            if (!event) return;
            
            // Award final rewards
            if (event.rewards) {
                Object.entries(event.rewards).forEach(([reward, amount]) => {
                    if (reward === 'seasonalCurrency') {
                        gameData.seasonal.seasonalCurrency += amount;
                    } else if (gameData.crafting.materials[reward]) {
                        gameData.crafting.materials[reward] += amount;
                    }
                });
            }
            
            gameData.seasonal.unlockedEvents.push(event.id);
            gameData.seasonal.currentEvent = null;
            
            alert(`üèÜ Seasonal Event Ended: ${event.name}!\nThank you for participating!`);
            saveGameData();
        }

        function getSeasonalModifiers() {
            const event = gameData.seasonal.currentEvent;
            if (!event || !event.modifiers) return {};
            
            return event.modifiers;
        }

        // Meta-Progression System
        function unlockGameMode(modeId) {
            if (!gameData.metaProgression.unlockedModes.includes(modeId)) {
                gameData.metaProgression.unlockedModes.push(modeId);
                alert(`üéÆ New Game Mode Unlocked: ${modeId}!`);
                saveGameData();
            }
        }

        function updateQualityOfLifeSetting(setting, value) {
            if (gameData.metaProgression.qualityOfLife.hasOwnProperty(setting)) {
                gameData.metaProgression.qualityOfLife[setting] = value;
                saveGameData();
            }
        }

        function checkMetaProgressionUnlocks() {
            const tier = calculateCharacterTier();
            const prestigeLevel = gameData.prestige.level;
            
            // Unlock game modes based on progression
            if (tier >= 5 && !gameData.metaProgression.unlockedModes.includes('speedrun')) {
                unlockGameMode('speedrun');
            }
            
            if (prestigeLevel >= 3 && !gameData.metaProgression.unlockedModes.includes('nightmare')) {
                unlockGameMode('nightmare');
            }
            
            if (tier >= 8 && !gameData.metaProgression.unlockedModes.includes('endless')) {
                unlockGameMode('endless');
            }
            
            // Unlock procedural content
            if (tier >= 6 && !gameData.procedural.dungeons.unlocked) {
                gameData.procedural.dungeons.unlocked = true;
                alert('üè∞ Procedural Dungeons Unlocked! New infinite content awaits!');
            }
            
            if (tier >= 10 && !gameData.procedural.infiniteZones.unlocked) {
                gameData.procedural.infiniteZones.unlocked = true;
                alert('‚ôæÔ∏è Infinite Zones Unlocked! Endless progression awaits!');
            }
        }

        // Procedural Dungeon System
        function generateProceduralDungeon(level = 1) {
            const dungeonTypes = ['Ancient Crypt', 'Shadow Labyrinth', 'Crystal Caverns', 'Void Sanctum', 'Celestial Tower'];
            const dungeonType = dungeonTypes[Math.floor(Math.random() * dungeonTypes.length)];
            
            const baseStats = {
                hp: 100 + (level * 25),
                power: 30 + (level * 8)
            };
            
            const enemies = generateDungeonEnemies(level);
            const rewards = generateDungeonRewards(level);
            
            const dungeon = {
                id: `dungeon_${Date.now()}`,
                name: `${dungeonType} - Level ${level}`,
                level: level,
                type: dungeonType,
                enemies: enemies,
                enemyStats: baseStats,
                rewards: rewards,
                floors: Math.min(10, 3 + Math.floor(level / 2)),
                currentFloor: 1,
                completed: false
            };
            
            return dungeon;
        }

        function generateDungeonEnemies(level) {
            const enemyPools = {
                1: ['Crypt Guardian', 'Shadow Wraith', 'Bone Warrior'],
                2: ['Void Specter', 'Crystal Golem', 'Ancient Skeleton'],
                3: ['Shadow Lord', 'Void Demon', 'Celestial Guardian'],
                4: ['Abyssal Horror', 'Nightmare Stalker', 'Reality Breaker'],
                5: ['Existence Ender', 'Null Entity', 'Cosmic Titan']
            };
            
            const tier = Math.min(5, Math.ceil(level / 2));
            return enemyPools[tier] || enemyPools[5];
        }

        function generateDungeonRewards(level) {
            const baseRewards = {
                gold: 500 + (level * 200),
                experience: 100 + (level * 50),
                materials: {}
            };
            
            // Add random materials based on level
            const materialTypes = ['enhancementStone', 'voidEssence', 'celestialShard', 'nightmareFragment'];
            materialTypes.forEach(material => {
                if (Math.random() < 0.7) {
                    baseRewards.materials[material] = Math.floor(Math.random() * level) + 1;
                }
            });
            
            return baseRewards;
        }

        function startProceduralDungeon(level = null) {
            if (!gameData.procedural.dungeons.unlocked) {
                alert('Procedural dungeons are not unlocked yet! Reach Tier 6 to unlock them.');
                return;
            }
            
            const dungeonLevel = level || gameData.procedural.dungeons.dungeonLevel;
            const dungeon = generateProceduralDungeon(dungeonLevel);
            
            gameData.procedural.dungeons.currentDungeon = dungeon;
            currentLocation = 'procedural_dungeon';
            
            alert(`üè∞ Entering ${dungeon.name}!\nFloors: ${dungeon.floors}\nEnemies: ${dungeon.enemies.join(', ')}\nRewards: ${dungeon.rewards.gold} gold + materials`);
            
            // Start combat in the dungeon
            if (confirm('Start exploring the dungeon?')) {
                startIdleCombat('procedural_dungeon');
                showScreen('combat');
            }
        }

        function completeDungeonFloor() {
            const dungeon = gameData.procedural.dungeons.currentDungeon;
            if (!dungeon) return;
            
            dungeon.currentFloor++;
            
            if (dungeon.currentFloor > dungeon.floors) {
                // Dungeon completed
                completeDungeon();
            } else {
                alert(`Floor ${dungeon.currentFloor - 1} completed! Moving to floor ${dungeon.currentFloor}...`);
                // Continue to next floor
                setTimeout(() => {
                    if (gameData.idleCombat.isActive) {
                        startNewCombat();
                    }
                }, 2000);
            }
        }

        function completeDungeon() {
            const dungeon = gameData.procedural.dungeons.currentDungeon;
            if (!dungeon) return;
            
            // Award rewards
            gameData.currency.gold += dungeon.rewards.gold;
            player.experience += dungeon.rewards.experience;
            
            Object.entries(dungeon.rewards.materials).forEach(([material, amount]) => {
                gameData.crafting.materials[material] += amount;
            });
            
            // Mark dungeon as completed
            dungeon.completed = true;
            gameData.procedural.dungeons.completedDungeons.push(dungeon.id);
            
            // Increase dungeon level for next run
            gameData.procedural.dungeons.dungeonLevel++;
            gameData.procedural.dungeons.maxDepth = Math.max(gameData.procedural.dungeons.maxDepth, dungeon.level);
            
            // Clear current dungeon
            gameData.procedural.dungeons.currentDungeon = null;
            currentLocation = null;
            
            alert(`üèÜ Dungeon Completed!\nRewards: ${dungeon.rewards.gold} gold, ${dungeon.rewards.experience} XP, materials\nNext dungeon level: ${gameData.procedural.dungeons.dungeonLevel}`);
            
            updateCurrencyDisplay();
            saveGameData();
        }

        // Infinite Zone System
        function generateInfiniteZone(level = 1) {
            const zoneNames = ['Infinite Void', 'Endless Abyss', 'Boundless Realm', 'Limitless Dimension'];
            const zoneName = zoneNames[Math.floor(Math.random() * zoneNames.length)];
            
            // Exponential scaling for infinite content
            const hpMultiplier = Math.pow(1.15, level);
            const powerMultiplier = Math.pow(1.12, level);
            
            const zone = {
                id: `infinite_${level}`,
                name: `${zoneName} - Level ${level}`,
                level: level,
                difficulty: 'infinite',
                description: `An endless realm where reality bends and power knows no limits.`,
                enemies: ['Void Walker', 'Null Entity', 'Existence Ender'],
                enemyStats: { 
                    hp: Math.floor(500 * hpMultiplier), 
                    power: Math.floor(150 * powerMultiplier) 
                },
                uniqueLoot: ['infinite'],
                recommendedStats: { 
                    Power: Math.floor(150 * Math.pow(1.1, level)), 
                    Dexterity: Math.floor(140 * Math.pow(1.1, level)), 
                    Vitality: Math.floor(135 * Math.pow(1.1, level)) 
                },
                rewards: {
                    gold: Math.floor(1000 * Math.pow(1.2, level)),
                    experience: Math.floor(200 * Math.pow(1.15, level)),
                    materials: {
                        voidEssence: Math.floor(level / 2) + 1,
                        enhancementStone: Math.floor(level / 3) + 1
                    }
                }
            };
            
            return zone;
        }

        function unlockInfiniteZone() {
            if (!gameData.procedural.infiniteZones.unlocked) {
                alert('Infinite zones are not unlocked yet! Reach Tier 10 to unlock them.');
                return;
            }
            
            const level = gameData.procedural.infiniteZones.currentLevel;
            const zone = generateInfiniteZone(level);
            
            // Add to locations temporarily
            gameData.locations[`infinite_${level}`] = zone;
            currentLocation = `infinite_${level}`;
            
            alert(`‚ôæÔ∏è Entering ${zone.name}!\nEnemy HP: ${zone.enemyStats.hp}\nEnemy Power: ${zone.enemyStats.power}\nRewards: ${zone.rewards.gold} gold + materials`);
            
            if (confirm('Start exploring the infinite zone?')) {
                startIdleCombat(`infinite_${level}`);
                showScreen('combat');
            }
        }

        function completeInfiniteZone() {
            const level = gameData.procedural.infiniteZones.currentLevel;
            const zone = gameData.locations[`infinite_${level}`];
            
            if (!zone) return;
            
            // Award rewards
            gameData.currency.gold += zone.rewards.gold;
            player.experience += zone.rewards.experience;
            
            Object.entries(zone.rewards.materials).forEach(([material, amount]) => {
                gameData.crafting.materials[material] += amount;
            });
            
            // Increase level for next run
            gameData.procedural.infiniteZones.currentLevel++;
            gameData.procedural.infiniteZones.maxLevel = Math.max(gameData.procedural.infiniteZones.maxLevel, level);
            
            // Remove temporary zone
            delete gameData.locations[`infinite_${level}`];
            currentLocation = null;
            
            alert(`‚ôæÔ∏è Infinite Zone Completed!\nLevel: ${level}\nRewards: ${zone.rewards.gold} gold, ${zone.rewards.experience} XP\nNext level: ${gameData.procedural.infiniteZones.currentLevel}`);
            
            updateCurrencyDisplay();
            saveGameData();
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Pandimus Reborn Player Version Loaded");
            console.log("DOM loaded, all functions should be available");
            
            // Try to load saved game data
            if (loadGameData()) {
                console.log("Saved game data loaded successfully");
                updateCharacterDisplay();
                updateToggleButtons(); // Initialize toggle button states
                updateCurrencyDisplay();
                
                // Initialize challenges if not present
                if (!gameData.challenges.daily.active) {
                    generateNewChallenge('daily');
                }
                if (!gameData.challenges.weekly.active) {
                    generateNewChallenge('weekly');
                }
                
                // Check seasonal events
                checkSeasonalEvents();
                
                // Check meta-progression unlocks
                checkMetaProgressionUnlocks();
                
                // Idle combat disabled - ensure it's not active
                if (gameData.idleCombat.isActive) {
                    gameData.idleCombat.isActive = false;
                    gameData.idleCombat.location = null;
                    gameData.idleCombat.startTime = null;
                    saveGameData();
                }
                
                // Offline progression disabled - combat must be earned through active gameplay
                // Removed offline progression calculation
                
                // Check challenge progress after loading
                setTimeout(() => {
                    checkChallengeProgress();
                }, 1000);
            } else {
                console.log("No saved game data found");
                updateCurrencyDisplay(); // Show default currency even without saved data
                
                // Initialize challenges for new game
                generateNewChallenge('daily');
                generateNewChallenge('weekly');
            }
        });
    </script>
</body>
</html>
